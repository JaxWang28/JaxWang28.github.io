<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kernel on Jackson Blog</title>
    <link>https://blog.jaxwang.top/tags/kernel/</link>
    <description>Recent content in Kernel on Jackson Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 07 May 2025 20:25:00 +0800</lastBuildDate>
    <atom:link href="https://blog.jaxwang.top/tags/kernel/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux - 内存管理 - NUMA ZONE</title>
      <link>https://blog.jaxwang.top/p/linux-memory-numa-zone-page/</link>
      <pubDate>Wed, 07 May 2025 20:25:00 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/linux-memory-numa-zone-page/</guid>
      <description>&lt;h1 id=&#34;0x01-numa-non-uniform-memory-access-概述&#34;&gt;0x01 NUMA Non-Uniform Memory Access 概述&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2025/04/54d2c03b18a4e0eab8c71c100f7a820f.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;单处理器时代&#34;&gt;单处理器时代&lt;/h2&gt;&#xA;&lt;p&gt;单核时代，CPU 与内存之间的关系是简单的。CPU 通过前端总线（FSB, Front Side Bus）连接到北桥芯片（集成内存控制器），北桥芯片连接到内存。&#xA;&lt;img src=&#34;https://img.jaxwang.top/2025/04/f49b62a3a29bc162d11b5bf6e1851693.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;多处理器时代&#34;&gt;多处理器时代&lt;/h2&gt;&#xA;&lt;p&gt;随着 CPU 的频率提高出现瓶颈，开始向多核发展。 出现了对称多处理器系统，多个 CPU 共享同一个内存池，通过总线 Bus 相连。每个 CPU 访问内存所需时间相同。这种架构称为 &lt;strong&gt;Uniform-memory-Access UMA&lt;/strong&gt;。使用总线就会存在资源争用和一致性问题，随着 CPU 数量增多争用愈演愈烈，以至于 4 核 CPU 性能达不到 2 核 1.5 倍。&lt;/p&gt;&#xA;&lt;p&gt;放弃总线的访问方式，将 CPU 划分到多个 Node 中，每个 Node 有自己独立的内存空间。各个 Node 之间通过高速互联通讯，通讯通道被成为QuickPath Interconnect 即 QPI。&lt;/p&gt;&#xA;&lt;p&gt;这种架构模型，cpu访问本地内存与远程内存所用的时间是不一样的，一般访问本地内存要比访问远程内存快，因此也被称做非一致或非均匀内存访问模型(Nonuniform-Memory-Access, 简称NUMA)。在 NUMA 中，每个 CPU（或 CPU 组）有自己的本地内存，同时也可以访问其他 CPU 的远程内存，但远程访问的延迟更高。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2025/04/3da9e0613ee79b63f12ab97135bac08d.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;一颗 CPU 一定在一个 Node 中。一个 Node 可以包含多颗 CPU。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;0x02-pg_data_t&#34;&gt;0x02 pg_data_t&lt;/h1&gt;&#xA;&lt;p&gt;Linux 在 2.6.7 版本引入 NUMA，并作为 Linux 物理内存管理的第一原则。这就意味着即使系统架构为 UMA 架构，Linux 也会将其视为 NUMA，只不过是只有一个 Node 的 NUMA 架构。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux - 数据结构 - list</title>
      <link>https://blog.jaxwang.top/p/linux-data-structure-list/</link>
      <pubDate>Wed, 30 Apr 2025 15:07:00 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/linux-data-structure-list/</guid>
      <description>&lt;p&gt;Linux 中实现了双向循环链表，和 hash 链表。&lt;/p&gt;&#xA;&lt;h1 id=&#34;0x01-双向链表-list_head&#34;&gt;0x01 双向链表 list_head&lt;/h1&gt;&#xA;&lt;p&gt;Linux 使用了最简洁的方式实现了一个几乎是万能的链表，其通过将下面结构体嵌入到其他结构体中，实现双向循环链表。在 &lt;code&gt;include/linux/list.h&lt;/code&gt; 定义了支持的所有操作。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;include/linux/types.h&lt;/em&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;struct list_head {&#xA;&#x9;struct list_head *next, *prev;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;mm/slab_common.c&lt;/em&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;LIST_HEAD(slab_caches);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;em&gt;mm/slab.h&lt;/em&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;struct kmem_cache {&#xA;    ....&#xA;    struct list_head list;&#x9;&#x9;/* List of slab caches */&#xA;    ....&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2025/04/c8590fa84ab49e876bb5296f2dc13712.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;从上面的例子中，指针指向的都是 &lt;code&gt;struct kmem_cache&lt;/code&gt; 中 &lt;code&gt;list&lt;/code&gt; 成员的地址，如何通过这个成员获得 &lt;code&gt;struct kmem_cache&lt;/code&gt; 的地址，在 Linux 中称为 &lt;code&gt;list_entry&lt;/code&gt; 的操作，通过下面代码实现：&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;include/linux/list.h&lt;/em&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;/**&#xA; * list_entry - get the struct for this entry&#xA; * @ptr:&#x9;the &amp;amp;struct list_head pointer.&#xA; * @type:&#x9;the type of the struct this is embedded in.&#xA; * @member:&#x9;the name of the list_head within the struct.&#xA; */&#xA;#define list_entry(ptr, type, member) \&#xA;&#x9;container_of(ptr, type, member)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;em&gt;include/linux/container_of.h&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux - 内存管理 - 物理内存模型</title>
      <link>https://blog.jaxwang.top/p/linux-memory-physical-memory-model/</link>
      <pubDate>Tue, 29 Apr 2025 16:30:00 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/linux-memory-physical-memory-model/</guid>
      <description>&lt;p&gt;4GB RAM 4KB 页面大小的 Linux 系统会产生一百万之多的 &lt;code&gt;struct page&lt;/code&gt;，组织管理这些结构体的方式我们称为内存模型。Linux 目前支持两种模型：&lt;code&gt;FLATMEM&lt;/code&gt; &lt;code&gt;SPARSEMEM&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;无论选择哪个内存模型，都会通过&lt;strong&gt;一个或多个数组&lt;/strong&gt;管理 &lt;code&gt;struct page&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h1 id=&#34;内存空洞-memory-hole&#34;&gt;内存空洞 memory hole&lt;/h1&gt;&#xA;&lt;p&gt;事实上 RAM 只是物理地址空间的一部分，物理地址空间通常会出现一部分地址是不用做普通内存使用的，对于这地址我们称之为&lt;strong&gt;内存空洞 Memory Hole&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;使用 &lt;code&gt;qemu-system-x86_64 -m 8G &lt;/code&gt; 启动 Kernel，可以看到下面 log&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;[    0.000000] BIOS-provided physical RAM map:&#xA;[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usable&#xA;[    0.000000] BIOS-e820: [mem 0x000000000009fc00-0x000000000009ffff] reserved&#xA;[    0.000000] BIOS-e820: [mem 0x00000000000f0000-0x00000000000fffff] reserved&#xA;[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x00000000bffdffff] usable&#xA;[    0.000000] BIOS-e820: [mem 0x00000000bffe0000-0x00000000bfffffff] reserved&#xA;[    0.000000] BIOS-e820: [mem 0x00000000fffc0000-0x00000000ffffffff] reserved&#xA;[    0.000000] BIOS-e820: [mem 0x0000000100000000-0x000000023fffffff] usable&#xA;[    0.000000] BIOS-e820: [mem 0x000000fd00000000-0x000000ffffffffff] reserved&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;对于其中 &lt;code&gt;reserved&lt;/code&gt; 的部分是不可作为普通内存使用的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux - 内存管理 - 页描述符</title>
      <link>https://blog.jaxwang.top/p/linux-memory-page-descriptor/</link>
      <pubDate>Tue, 29 Apr 2025 16:25:00 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/linux-memory-page-descriptor/</guid>
      <description>&lt;p&gt;Linux 使用分页技术，因此对物理内存管理的基本单位是 &lt;strong&gt;Page Frame 页框&lt;/strong&gt;。Linux 必须对每一个 Page Frame 了如执掌，其通过为每个页框分配一个&lt;strong&gt;页描述符&lt;/strong&gt; &lt;code&gt;struct page&lt;/code&gt; 保存页框的基本信息。&lt;/p&gt;&#xA;&lt;p&gt;对于一个物理地址空间 4GB PAGE_SIZE=4KB Linux 系统，Linux 分配 &lt;code&gt;4GB/4KB = 1M = 2^20&lt;/code&gt; 大约一百万个 &lt;code&gt;struct page&lt;/code&gt; 结构体，尽管这是个庞大的数量，但这是不可避免的。&lt;/p&gt;&#xA;&lt;p&gt;这里我们可以得到一个对应关系:&#xA;&lt;img src=&#34;https://img.jaxwang.top/2025/04/b5b82570c1935e7949d19886729d2a67.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Linux 中定义了两个宏进行 PFN 与 &lt;code&gt;struct page&lt;/code&gt; 之间的转换：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;page_to_pfn&#xA;pfn_to_page&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这两个宏的具体实现依赖于 Linux 使用的物理内存模型，将在后文展开。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;include/linux/mm_types.h&lt;/em&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;/*&#xA; * Each physical page in the system has a struct page associated with&#xA; * it to keep track of whatever it is we are using the page for at the&#xA; * moment. Note that we have no way to track which tasks are using&#xA; * a page, though if it is a pagecache page, rmap structures can tell us&#xA; * who is mapping it.&#xA; */&#xA;struct page {&#xA;    ...&#xA;    unsigned long flags;&#xA;    ...&#x9;&#xA;} _struct_page_alignment;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Linux - 内存管理 - 分页虚拟存储理论</title>
      <link>https://blog.jaxwang.top/p/linux-memory-paging-fundamental/</link>
      <pubDate>Sat, 26 Apr 2025 14:37:06 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/linux-memory-paging-fundamental/</guid>
      <description>&lt;h1 id=&#34;0x00-很久之前&#34;&gt;0x00 很久之前&lt;/h1&gt;&#xA;&lt;p&gt;在很久之前，计算机使用单程序存储管理。&#xA;&lt;img src=&#34;https://img.jaxwang.top/2025/04/ff061f834f1d31c57ea6d8cdf56f5f5f.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在这种管理模式下，每次只能运行一个程序。操作系统每次将相应的程序从磁盘加载到 RAM 中。直至进程运行结束后跳转到操作系统代码，操作系统再根据用户需求将程序装入 RAM 中，覆盖掉旧的程序。存在问题：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一次只能运行一个程序&lt;/li&gt;&#xA;&lt;li&gt;进程（程序）的切换很慢&lt;/li&gt;&#xA;&lt;li&gt;程序的大小取决于 RAM 物理内存的大小&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;em&gt;事实上，后面又发展了多道程序，交换技术等技术来试图解决上述问题但效果不好，这里就不展开讲了，但为什么会讲一下单道存储管理，因为其与 Linux 虚拟存储空间布局很像，暂时无需知道什么是虚拟存储空间。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;0x01-虚拟存储器-virtual-memory&#34;&gt;0x01 虚拟存储器 Virtual Memory&lt;/h1&gt;&#xA;&lt;p&gt;虚拟存储技术发展的根本原因：&#xA;RAM 小且昂贵，无论是上世纪还是当下，RAM 都是小且昂贵的资源，所以我们不得不充分利用，进而发展出虚拟存储技术。假设我们的 RAM 可以无限大且廉价。&#xA;&lt;img src=&#34;https://img.jaxwang.top/2025/04/218c50bcec6a497456a3a8e11f1e4d1e.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;虚拟存储的基础及事实：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;局部性原理：程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。这也意味着并不需要完全把程序加载到 RAM 也能保证程序的执行。&lt;/li&gt;&#xA;&lt;li&gt;磁盘空间很大且足够便宜，可以把程序暂时不需要的那一部分放在磁盘上，把需要的那部分放在 RAM 上。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Virtual Memroy[1] 由 Fotheringham 在 1961 年提出[2]，其基本思想是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;程序的代码数据和栈的总大小可以超过物理内存（RAM）&lt;/li&gt;&#xA;&lt;li&gt;操作系统将正在运行的程序的需要的那部分保留在内存中，而将当前不使用的部分放置在磁盘上，根据需要调入内存。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2025/04/ad0efef73393d346579d2f240337f46a.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;根据虚拟存储器实现的技术可以分为：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;页式：采用 &lt;strong&gt;分页 Paging&lt;/strong&gt; 技术&lt;/li&gt;&#xA;&lt;li&gt;段式：采用 &lt;strong&gt;分段 Segmentation&lt;/strong&gt; 技术&lt;/li&gt;&#xA;&lt;li&gt;分页分段结合：Paged Segmentation&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;目前大多数虚拟存储管理系统都采用&lt;strong&gt;分页 paging&lt;/strong&gt; 技术，本文也仅讲解分页存储管理。&lt;/p&gt;&#xA;&lt;h1 id=&#34;0x02-分页基本思想&#34;&gt;0x02 分页基本思想&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将物理内存划分为为许多固定大小（&lt;strong&gt;PAGE SIZE&lt;/strong&gt;）的内存块 ，称为&lt;strong&gt;物理页面 页框 page frame&lt;/strong&gt;,并为每个页框从低地址开始编号称为&lt;strong&gt;PFN&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;将程序（用户程序和OS）中使用的地址称为&lt;strong&gt;虚拟地址&lt;/strong&gt;，并构成&lt;strong&gt;虚拟地址空间&lt;/strong&gt;。将虚拟地址空间划分为大小相同的块，称为&lt;strong&gt;虚拟页面 page&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;CPU 访问程序中使用的地址时，并不是放在地址总线上，而是被送往&lt;strong&gt;存储管理单元 MMU&lt;/strong&gt;，其利用映射关系（其实就是页表）将虚拟地址转化为物理地址后再进行访问。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux - 进程管理 - 进程描述符 - state</title>
      <link>https://blog.jaxwang.top/p/linux-progress-taskstruct-state/</link>
      <pubDate>Sun, 20 Apr 2025 17:26:06 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/linux-progress-taskstruct-state/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2025/04/36b9b75b2ec34273e0b4b59a2d746966.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;include/linux/sched.h&#xA;&#xA;struct task_struct {&#xA;    ....&#xA;&#x9;unsigned int __state;&#xA;&#x9;...&#xA;}&#xA;&#xA;/* Used in tsk-&amp;gt;__state: */&#xA;#define TASK_RUNNING            0x00000000&#xA;#define TASK_INTERRUPTIBLE      0x00000001&#xA;#define TASK_UNINTERRUPTIBLE    0x00000002&#xA;#define __TASK_STOPPED          0x00000004&#xA;#define __TASK_TRACED           0x00000008&#xA;/* Used in tsk-&amp;gt;exit_state: */&#xA;#define EXIT_DEAD               0x00000010&#xA;#define EXIT_ZOMBIE             0x00000020&#xA;#define EXIT_TRACE              (EXIT_ZOMBIE | EXIT_DEAD)&#xA;/* Used in tsk-&amp;gt;__state again: */&#xA;#define TASK_PARKED             0x00000040&#xA;#define TASK_DEAD               0x00000080&#xA;#define TASK_WAKEKILL           0x00000100&#xA;#define TASK_WAKING             0x00000200&#xA;#define TASK_NOLOAD             0x00000400&#xA;#define TASK_NEW                0x00000800&#xA;#define TASK_RTLOCK_WAIT        0x00001000&#xA;#define TASK_FREEZABLE          0x00002000&#xA;#define __TASK_FREEZABLE_UNSAFE (0x00004000 * IS_ENABLED(CONFIG_LOCKDEP))&#xA;#define TASK_FROZEN             0x00008000&#xA;#define TASK_STATE_MAX          0x00010000&#xA;#define TASK_ANY                (TASK_STATE_MAX-1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;State&lt;/th&gt;&#xA;          &lt;th&gt;Description&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TASK_RUNNING&lt;/td&gt;&#xA;          &lt;td&gt;可运行状态：进程要么在 CPU 上执行，要么准备执行&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TASK_INTERRUPTIBLE&lt;/td&gt;&#xA;          &lt;td&gt;可中断的等待状态：进程被挂起（睡眠），直到某个条件为真。产生硬件中断，释放进程等待的系统资源，或传递一个信号都可以唤起进程。进程唤起后状态回到 TASK_RUNNING&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TASK_UNINTERRUPTIBLE&lt;/td&gt;&#xA;          &lt;td&gt;不可中断的挂起状态：忽略任何信号。进程必须在不被打断的情况下等待某个事件的发生&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;__TASK_STOPPED&lt;/td&gt;&#xA;          &lt;td&gt;暂停状态：进程执行被暂停，进程收到 SIGSTOP SIGTTIN SIGTSTP SIGTTOU 信号后进入暂停状态&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;__TASK_TRACED&lt;/td&gt;&#xA;          &lt;td&gt;跟踪状态：进程的执行已由 debugger 程序暂停。当一个进程被另一个进程监控时，每一个信号都会让进程进入此状态&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;EXIT_ZOMBIE&lt;/td&gt;&#xA;          &lt;td&gt;僵死状态：进程的执行被终止，但是父进程还没有发布 &lt;code&gt;wait4()&lt;/code&gt; 和 &lt;code&gt;waitpid()&lt;/code&gt; 系统调用来返回有关死亡进程的信息。此时内核还不能丢弃死亡进程描述符中的数据，父进程还可能需要&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;EXIT_DEAD&lt;/td&gt;&#xA;          &lt;td&gt;僵死撤销状态：父进程刚发出 &lt;code&gt;wait4()&lt;/code&gt; &lt;code&gt;waitpid()&lt;/code&gt; 系统调用，进程由系统删除。为了防止其它执行线程在同一个进程上也执行 &lt;code&gt;wait()&lt;/code&gt; 类系统调用，把进程从 &lt;code&gt;EXIT_ZOMBIE&lt;/code&gt; 切换到 &lt;code&gt;EXIT_DEAD&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h1 id=&#34;ref&#34;&gt;Ref.&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://blog.jaxwang.top/p/linux-progress-taskstruct-state/&#34;&gt;https://blog.jaxwang.top/p/linux-progress-taskstruct-state/&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>x86 Linux 启动第二阶段 - protected mode</title>
      <link>https://blog.jaxwang.top/p/x86-linux-kernet-boot-setup/</link>
      <pubDate>Sun, 20 Apr 2025 11:04:06 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/x86-linux-kernet-boot-setup/</guid>
      <description>&lt;p&gt;bootloader 在将 kernel 加载到 &lt;code&gt;0x100000&lt;/code&gt; 后设置 &lt;code&gt;boot_params.hdr.code32_start&lt;/code&gt; ，这个地址 &lt;code&gt;protected_mode&lt;/code&gt; 内核的开始地址即 &lt;code&gt;0x100000&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;(gdb) x/32x 0x100000&#xA;0x100000:       0xfc    0xfa    0x8d    0xa6    0xe8    0x01    0x00    0x00&#xA;0x100008:       0xe8    0x00    0x00    0x00    0x00    0x5d    0x83    0xed&#xA;&#xA;readelf -x .head.text arch/x86/boot/compressed/vmlinux&#xA;0x00000000 fcfa8da6 e8010000 e8000000 005d83ed .............]..&#xA;0x00000010 0d8d8510 f0c90089 40020f01 10b81800 ........@.......&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;第一张全局描述符表-gdt&#34;&gt;第一张全局描述符表 GDT&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;SYM_DATA_START_LOCAL(gdt)&#xA;        .word   gdt_end - gdt - 1&#xA;        .long   0&#xA;        .word   0&#xA;        .quad   0x00cf9a000000ffff      /* __KERNEL32_CS */&#xA;        .quad   0x00af9a000000ffff      /* __KERNEL_CS */&#xA;        .quad   0x00cf92000000ffff      /* __KERNEL_DS */&#xA;        .quad   0x0080890000000000      /* TS descriptor */&#xA;        .quad   0x0000000000000000      /* TS continued */&#xA;SYM_DATA_END_LABEL(gdt, SYM_L_LOCAL, gdt_end)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2025/04/441e0ef44d4aa8bef05b2ab190446907.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>x86 Linux 启动第一阶段 - setup</title>
      <link>https://blog.jaxwang.top/p/x86-linux-kernet-boot-setup/</link>
      <pubDate>Sat, 19 Apr 2025 20:45:06 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/x86-linux-kernet-boot-setup/</guid>
      <description>&lt;pre&gt;&lt;code&gt;linux-6.12.4&#xA;QEMU emulator version 8.2.2 (Debian 1:8.2.2+ds-0ubuntu1.6)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;魔数-mz&#34;&gt;魔数 MZ&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;readelf -x .bstext  arch/x86/boot/setup.elf&#xA;Hex dump of section &#39;.bstext&#39;:&#xA;0x00000000 4d5a0000 00000000 00000000 00000000 MZ..............&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;xxd arch/x86/boot/setup.bin&#xA;00000000: 4d5a 0000 0000 0000 0000 0000 0000 0000  MZ..............&#xA;00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;(gdb) hb *0x10200&#xA;(gdb) c&#xA;(gdb) x/2c 0x10000&#xA;0x10000 &amp;lt;exception_stacks+16384&amp;gt;:       77 &#39;M&#39;  90 &#39;Z&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;setup-过程函数跳转&#34;&gt;setup 过程函数跳转&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2025/04/1ea16f28231769c5f553393cfd522178.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;_start&#34;&gt;_start&lt;/h1&gt;&#xA;&lt;p&gt;bootloader 将 &lt;code&gt;setup.bin&lt;/code&gt; 加载到 &lt;code&gt;0x10000&lt;/code&gt; 地址处后，将 &lt;code&gt;CS&lt;/code&gt; 置为 &lt;code&gt;0x1020&lt;/code&gt; ，&lt;code&gt;IP&lt;/code&gt; 置为 &lt;code&gt;0x0&lt;/code&gt;。通过计算可以得知地址为 &lt;code&gt;0x10200&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>WSL2 Kernel 升级更换</title>
      <link>https://blog.jaxwang.top/p/wsl2-kernel-update/</link>
      <pubDate>Wed, 14 Aug 2024 11:04:51 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/wsl2-kernel-update/</guid>
      <description>&lt;p&gt;&lt;strong&gt;! Warning&lt;/strong&gt;&lt;br&gt;&#xA;If you have multiple distros installed, they will all use the same kernel.&lt;br&gt;&#xA;WSL2 中不同发行版使用的是同一个内核。&lt;br&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;0x01-准备&#34;&gt;0x01 准备&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;源码&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/microsoft/WSL2-Linux-Kernel.git&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;toolchain&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt update &amp;amp;&amp;amp; sudo apt install build-essential flex bison libssl-dev libelf-dev bc python3 pahole&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;查看源码分支选择版本&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 查看所有版本&#xA;git tag &#xA;&#xA;# 选择目前最新版本&#xA;git checkout linux-msft-wsl-6.6.36.3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;0x02-构建&#34;&gt;0x02 构建&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;make menuconfig KCONFIG_CONFIG=Microsoft/config-wsl&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;make -j$(nproc) KCONFIG_CONFIG=Microsoft/config-wsl&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;0x03-安装&#34;&gt;0x03 安装&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo make modules_install headers_install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;cp arch/x86/boot/bzImage /mnt/c/User/&amp;lt;username&amp;gt;/bzImage&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;创建 &lt;code&gt;%USERPROFILE%\.wslconfig&lt;/code&gt; 并添加下面内容&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
