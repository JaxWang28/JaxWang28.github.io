<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Memory on Jackson Blog</title>
    <link>https://blog.jaxwang.top/tags/memory/</link>
    <description>Recent content in Memory on Jackson Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 07 May 2025 20:25:00 +0800</lastBuildDate>
    <atom:link href="https://blog.jaxwang.top/tags/memory/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux - 内存管理 - NUMA ZONE</title>
      <link>https://blog.jaxwang.top/p/linux-memory-numa-zone-page/</link>
      <pubDate>Wed, 07 May 2025 20:25:00 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/linux-memory-numa-zone-page/</guid>
      <description>&lt;h1 id=&#34;0x01-numa-non-uniform-memory-access-概述&#34;&gt;0x01 NUMA Non-Uniform Memory Access 概述&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2025/04/54d2c03b18a4e0eab8c71c100f7a820f.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;单处理器时代&#34;&gt;单处理器时代&lt;/h2&gt;&#xA;&lt;p&gt;单核时代，CPU 与内存之间的关系是简单的。CPU 通过前端总线（FSB, Front Side Bus）连接到北桥芯片（集成内存控制器），北桥芯片连接到内存。&#xA;&lt;img src=&#34;https://img.jaxwang.top/2025/04/f49b62a3a29bc162d11b5bf6e1851693.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;多处理器时代&#34;&gt;多处理器时代&lt;/h2&gt;&#xA;&lt;p&gt;随着 CPU 的频率提高出现瓶颈，开始向多核发展。 出现了对称多处理器系统，多个 CPU 共享同一个内存池，通过总线 Bus 相连。每个 CPU 访问内存所需时间相同。这种架构称为 &lt;strong&gt;Uniform-memory-Access UMA&lt;/strong&gt;。使用总线就会存在资源争用和一致性问题，随着 CPU 数量增多争用愈演愈烈，以至于 4 核 CPU 性能达不到 2 核 1.5 倍。&lt;/p&gt;&#xA;&lt;p&gt;放弃总线的访问方式，将 CPU 划分到多个 Node 中，每个 Node 有自己独立的内存空间。各个 Node 之间通过高速互联通讯，通讯通道被成为QuickPath Interconnect 即 QPI。&lt;/p&gt;&#xA;&lt;p&gt;这种架构模型，cpu访问本地内存与远程内存所用的时间是不一样的，一般访问本地内存要比访问远程内存快，因此也被称做非一致或非均匀内存访问模型(Nonuniform-Memory-Access, 简称NUMA)。在 NUMA 中，每个 CPU（或 CPU 组）有自己的本地内存，同时也可以访问其他 CPU 的远程内存，但远程访问的延迟更高。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2025/04/3da9e0613ee79b63f12ab97135bac08d.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;一颗 CPU 一定在一个 Node 中。一个 Node 可以包含多颗 CPU。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;0x02-pg_data_t&#34;&gt;0x02 pg_data_t&lt;/h1&gt;&#xA;&lt;p&gt;Linux 在 2.6.7 版本引入 NUMA，并作为 Linux 物理内存管理的第一原则。这就意味着即使系统架构为 UMA 架构，Linux 也会将其视为 NUMA，只不过是只有一个 Node 的 NUMA 架构。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux - 内存管理 - 物理内存模型</title>
      <link>https://blog.jaxwang.top/p/linux-memory-physical-memory-model/</link>
      <pubDate>Tue, 29 Apr 2025 16:30:00 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/linux-memory-physical-memory-model/</guid>
      <description>&lt;p&gt;4GB RAM 4KB 页面大小的 Linux 系统会产生一百万之多的 &lt;code&gt;struct page&lt;/code&gt;，组织管理这些结构体的方式我们称为内存模型。Linux 目前支持两种模型：&lt;code&gt;FLATMEM&lt;/code&gt; &lt;code&gt;SPARSEMEM&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;无论选择哪个内存模型，都会通过&lt;strong&gt;一个或多个数组&lt;/strong&gt;管理 &lt;code&gt;struct page&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h1 id=&#34;内存空洞-memory-hole&#34;&gt;内存空洞 memory hole&lt;/h1&gt;&#xA;&lt;p&gt;事实上 RAM 只是物理地址空间的一部分，物理地址空间通常会出现一部分地址是不用做普通内存使用的，对于这地址我们称之为&lt;strong&gt;内存空洞 Memory Hole&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;使用 &lt;code&gt;qemu-system-x86_64 -m 8G &lt;/code&gt; 启动 Kernel，可以看到下面 log&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;[    0.000000] BIOS-provided physical RAM map:&#xA;[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usable&#xA;[    0.000000] BIOS-e820: [mem 0x000000000009fc00-0x000000000009ffff] reserved&#xA;[    0.000000] BIOS-e820: [mem 0x00000000000f0000-0x00000000000fffff] reserved&#xA;[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x00000000bffdffff] usable&#xA;[    0.000000] BIOS-e820: [mem 0x00000000bffe0000-0x00000000bfffffff] reserved&#xA;[    0.000000] BIOS-e820: [mem 0x00000000fffc0000-0x00000000ffffffff] reserved&#xA;[    0.000000] BIOS-e820: [mem 0x0000000100000000-0x000000023fffffff] usable&#xA;[    0.000000] BIOS-e820: [mem 0x000000fd00000000-0x000000ffffffffff] reserved&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;对于其中 &lt;code&gt;reserved&lt;/code&gt; 的部分是不可作为普通内存使用的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux - 内存管理 - 页描述符</title>
      <link>https://blog.jaxwang.top/p/linux-memory-page-descriptor/</link>
      <pubDate>Tue, 29 Apr 2025 16:25:00 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/linux-memory-page-descriptor/</guid>
      <description>&lt;p&gt;Linux 使用分页技术，因此对物理内存管理的基本单位是 &lt;strong&gt;Page Frame 页框&lt;/strong&gt;。Linux 必须对每一个 Page Frame 了如执掌，其通过为每个页框分配一个&lt;strong&gt;页描述符&lt;/strong&gt; &lt;code&gt;struct page&lt;/code&gt; 保存页框的基本信息。&lt;/p&gt;&#xA;&lt;p&gt;对于一个物理地址空间 4GB PAGE_SIZE=4KB Linux 系统，Linux 分配 &lt;code&gt;4GB/4KB = 1M = 2^20&lt;/code&gt; 大约一百万个 &lt;code&gt;struct page&lt;/code&gt; 结构体，尽管这是个庞大的数量，但这是不可避免的。&lt;/p&gt;&#xA;&lt;p&gt;这里我们可以得到一个对应关系:&#xA;&lt;img src=&#34;https://img.jaxwang.top/2025/04/b5b82570c1935e7949d19886729d2a67.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Linux 中定义了两个宏进行 PFN 与 &lt;code&gt;struct page&lt;/code&gt; 之间的转换：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;page_to_pfn&#xA;pfn_to_page&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这两个宏的具体实现依赖于 Linux 使用的物理内存模型，将在后文展开。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;include/linux/mm_types.h&lt;/em&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;/*&#xA; * Each physical page in the system has a struct page associated with&#xA; * it to keep track of whatever it is we are using the page for at the&#xA; * moment. Note that we have no way to track which tasks are using&#xA; * a page, though if it is a pagecache page, rmap structures can tell us&#xA; * who is mapping it.&#xA; */&#xA;struct page {&#xA;    ...&#xA;    unsigned long flags;&#xA;    ...&#x9;&#xA;} _struct_page_alignment;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
