<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Linux - 数据结构 - list | Jackson Blog</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
<link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
<link rel="manifest" href="/favicon/site.webmanifest">


      <script async src="https://www.googletagmanager.com/gtag/js?id=7S26TLKGMX"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', '7S26TLKGMX');
        }
      </script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <meta name="referrer" content="no-referrer-when-downgrade">
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/post/">Posts</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/">RSS</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Linux - 数据结构 - list</span></h1>

<h2 class="date">
 2025/04/30 
&nbsp
<span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span>次阅读量</span>
</h2>
</div>

<main>
<p>Linux 中实现了双向循环链表，和 hash 链表。</p>
<h1 id="0x01-双向链表-list_head">0x01 双向链表 list_head</h1>
<p>Linux 使用了最简洁的方式实现了一个几乎是万能的链表，其通过将下面结构体嵌入到其他结构体中，实现双向循环链表。在 <code>include/linux/list.h</code> 定义了支持的所有操作。</p>
<p><em>include/linux/types.h</em></p>
<pre><code>struct list_head {
	struct list_head *next, *prev;
};
</code></pre>
<p><strong>Example</strong></p>
<p><em>mm/slab_common.c</em></p>
<pre><code>LIST_HEAD(slab_caches);
</code></pre>
<p><em>mm/slab.h</em></p>
<pre><code>struct kmem_cache {
    ....
    struct list_head list;		/* List of slab caches */
    ....
}
</code></pre>
<p><img src="https://img.jaxwang.top/2025/04/c8590fa84ab49e876bb5296f2dc13712.png" alt=""></p>
<p>从上面的例子中，指针指向的都是 <code>struct kmem_cache</code> 中 <code>list</code> 成员的地址，如何通过这个成员获得 <code>struct kmem_cache</code> 的地址，在 Linux 中称为 <code>list_entry</code> 的操作，通过下面代码实现：</p>
<p><em>include/linux/list.h</em></p>
<pre><code>/**
 * list_entry - get the struct for this entry
 * @ptr:	the &amp;struct list_head pointer.
 * @type:	the type of the struct this is embedded in.
 * @member:	the name of the list_head within the struct.
 */
#define list_entry(ptr, type, member) \
	container_of(ptr, type, member)
</code></pre>
<p><em>include/linux/container_of.h</em></p>
<pre><code>/**
 * container_of - cast a member of a structure out to the containing structure
 * @ptr:	the pointer to the member.
 * @type:	the type of the container struct this is embedded in.
 * @member:	the name of the member within the struct.
 *
 * WARNING: any const qualifier of @ptr is lost.
 */
#define container_of(ptr, type, member) ({				\
	void *__mptr = (void *)(ptr);					\
	static_assert(__same_type(*(ptr), ((type *)0)-&gt;member) ||	\
		      __same_type(*(ptr), void),			\
		      &quot;pointer type mismatch in container_of()&quot;);	\
	((type *)(__mptr - offsetof(type, member))); })
</code></pre>
<p><em>tools/include/linux/kernel.h</em></p>
<pre><code>#ifndef offsetof
#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)
#endif
</code></pre>
<ol>
<li><code>offsetof</code> 计算结构体中某个成员的偏移量，其通过强转假设地址 0 处有一个 TYPE 类型的结构体，<code>-&gt;</code>指针取结构体成员 Member，最后通过 <code>&amp;</code> 获得 Member 的地址，并强转为 <code>size_t</code> 类型。</li>
<li><code>container_of</code> 利用成员指针，获得结构体的指针。<strong>成员指针 - 成员的偏移量=结构体指针</strong></li>
<li><code>list_entry</code> list_head 作为一个成员嵌入到结构体中，已知 list_head 指针，调用 <code>container_of</code> 获得结构体指针。</li>
</ol>
<h1 id="0x02-hash-链表-hlist_">0x02 hash 链表 hlist_</h1>
<p>linux 中定义 <code>hlist_head</code> 用作 hash 表中的链表头，<code>hlist_node</code> 用作链表中的某一项。</p>
<p><em>include/linux/types.h</em></p>
<pre><code>struct hlist_head {
	struct hlist_node *first;
};

struct hlist_node {
	struct hlist_node *next, **pprev;
};
</code></pre>
<p><img src="https://img.jaxwang.top/2025/04/743a01bbad60899615e2f1507da5f383.png" alt=""></p>
<p>Linux 设计 <code>hlist_head</code> 仅包含一个指针用作 hash_table 中的列表头，这样可以节省很大空间，特别是当 hash bucket 很大的时候，可以节省一半空间。</p>
<p>散列表的冲突情况很少，链表不会很长，遍历很快。将 <code>pprev</code> 设计为指向前一个节点的 <code>next</code> 很容易实现删除操作。</p>
<p><em>include/linux/list.h</em></p>
<pre><code>static inline void __hlist_del(struct hlist_node *n)
{
	struct hlist_node *next = n-&gt;next;
	struct hlist_node **pprev = n-&gt;pprev;

	WRITE_ONCE(*pprev, next);
	if (next)
		WRITE_ONCE(next-&gt;pprev, pprev);
}
</code></pre>
<h1 id="0x03-ref">0x03 Ref</h1>
<p><a href="https://blog.csdn.net/weixin_39094034/article/details/104803967">https://blog.csdn.net/weixin_39094034/article/details/104803967</a></p>
<p><a href="https://linux.laoqinren.net/kernel/hlist/">https://linux.laoqinren.net/kernel/hlist/</a></p>

</main>
<hr/>

<script src="https://giscus.app/client.js"
        data-repo="JaxWang28/Blog"
        data-repo-id="R_kgDOIbrexg"
        data-category="Announcements"
        data-category-id="DIC_kwDOIbrexs4CSjN8"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
</script>
  <footer>
  <hr/>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="//cdn.jsdelivr.net/combine/npm/katex/dist/katex.min.js,npm/katex/dist/contrib/auto-render.min.js,npm/@xiee/utils/js/render-katex.js" defer></script>

<script src="//cdn.jsdelivr.net/npm/@xiee/utils/js/center-img.min.js" defer></script>


<div class="busuanzi-footer">
  <span id="busuanzi_container_site_pv">
    总访问量 <span id="busuanzi_value_site_pv"></span> 次
  </span>
  <span id="busuanzi_container_site_uv">
    访客数 <span id="busuanzi_value_site_uv"></span> 人次
  </span>
</div>
  
  <hr/>
  © <a href="https://jaxwang28.github.io">Jackson Wang</a> 2017 &ndash; 2025 | <a href="https://github.com/jaxwang28">Github</a>
  
  </footer>
  </body>
</html>

