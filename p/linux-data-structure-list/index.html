<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <title>Linux Kernel 数据结构分析之链表</title>
    <meta name="description" content="Linux Kernel 内核中链表实现及其实现原理。">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="/css/github-markdown-light.css" />
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
    <link rel="manifest" href="/favicon/site.webmanifest">

  </head>

  <body>
    <nav>
      <ul class="menu">
        
        <li><a href="/">Home</a></li>
        
        <li><a href="/post/">Posts</a></li>
        
        <li><a href="/categories/">Categories</a></li>
        
        <li><a href="/tags/">Tags</a></li>
        
        <li><a href="/about/">About</a></li>
        
        <li><a href="/bookshelf">Bookshelf</a></li>
        
        <li><a href="/index.xml">RSS</a></li>
        
      </ul>
      <hr/>
    </nav>

<div style="margin-left: auto; margin-right: 0; text-align: right;" >
  📅
   2025/04/30 
</div>
<div class="markdown-box">
<main class="markdown-body">
<h1 id="linux-kernel-数据结构分析之链表">Linux Kernel 数据结构分析之链表</h1>
<p>Linux Kernel 中实现了以下两种链表：</p>
<ul>
<li>双向循环链表</li>
<li>hash 链表</li>
</ul>
<p>本文将分别分析两种链表的实现。</p>
<h2 id="一双向循环链表">一、双向循环链表</h2>
<p>Linux 使用了最简洁的方式实现了一个几乎是万能的链表，其通过将 <code>struct list_head</code> <strong>嵌入到其他结构体中</strong>，实现双向循环链表。并在 <code>include/linux/list.h</code> 定义了支持的所有操作。</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/types.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> list_head {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>next, <span style="color:#f92672">*</span>prev;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></td></tr></table>
</div>
</div><p>以 <code>keme_caches</code> 链表进行分析。</p>
<pre tabindex="0"><code>// mm/slab_common.c

LIST_HEAD(slab_caches);
</code></pre><pre tabindex="0"><code>// mm/slab.h

struct kmem_cache {
    ....
    struct list_head list;		/* List of slab caches */
    ....
}
</code></pre><center><img src="https://img.jaxwang.top/2025/04/c8590fa84ab49e876bb5296f2dc13712.png" width="70%" height="70%"> </center>
<p>上面的例子中，指针指向是 <code>struct kmem_cache</code> 中 <code>list</code> 成员。通过这个成员的地址获得 <code>struct kmem_cache</code> 的地址的操作，在 Linux 中通过 <code>list_entry</code> 实现。下面分析其实现逻辑。</p>
<pre tabindex="0"><code>// include/linux/list.h

/**
 * list_entry - get the struct for this entry
 * @ptr:	the &amp;struct list_head pointer.
 * @type:	the type of the struct this is embedded in.
 * @member:	the name of the list_head within the struct.
 */
#define list_entry(ptr, type, member) \
	container_of(ptr, type, member)
</code></pre><pre tabindex="0"><code>// include/linux/container_of.h

/**
 * container_of - cast a member of a structure out to the containing structure
 * @ptr:	the pointer to the member.
 * @type:	the type of the container struct this is embedded in.
 * @member:	the name of the member within the struct.
 *
 * WARNING: any const qualifier of @ptr is lost.
 */
#define container_of(ptr, type, member) ({				\
	void *__mptr = (void *)(ptr);					\
	static_assert(__same_type(*(ptr), ((type *)0)-&gt;member) ||	\
		      __same_type(*(ptr), void),			\
		      &#34;pointer type mismatch in container_of()&#34;);	\
	((type *)(__mptr - offsetof(type, member))); })
</code></pre><pre tabindex="0"><code>// tools/include/linux/kernel.h

#ifndef offsetof
#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)
#endif
</code></pre><ol>
<li><code>offsetof</code> 计算结构体中某个成员的偏移量，其通过强转假设地址 0 处有一个 TYPE 类型的结构体，<code>-&gt;</code>指针取结构体成员 Member，最后通过 <code>&amp;</code> 获得 Member 的地址，并强转为 <code>size_t</code> 类型。</li>
<li><code>container_of</code> 利用成员指针，获得结构体的指针。<strong>成员指针 - 成员的偏移量=结构体指针</strong></li>
<li><code>list_entry</code> list_head 作为一个成员嵌入到结构体中，已知 list_head 指针，调用 <code>container_of</code> 获得结构体指针。</li>
</ol>
<h2 id="二hash-链表">二、hash 链表</h2>
<p>linux kernel 中定义 <code>hlist_head</code> 用作 hash 表中的链表头，<code>hlist_node</code> 用作链表中的某一项。</p>
<pre tabindex="0"><code>// include/linux/types.h

struct hlist_head {
	struct hlist_node *first;
};

struct hlist_node {
	struct hlist_node *next, **pprev;
};
</code></pre><center><img src="https://img.jaxwang.top/2025/04/743a01bbad60899615e2f1507da5f383.png" width="70%" height="70%"></center>
<p>Linux kernel 设计 <code>hlist_head</code> 仅包含一个指针用作 hash_table 中的列表头，这样可以节省很大空间，特别是当 hash bucket 很大的时候，可以节省一半空间。</p>
<p>散列表的冲突情况很少，链表不会很长，遍历很快。将 <code>pprev</code> 设计为指向前一个节点的 <code>next</code> 很容易实现删除操作。</p>
<pre tabindex="0"><code>// include/linux/list.h

static inline void __hlist_del(struct hlist_node *n)
{
	struct hlist_node *next = n-&gt;next;
	struct hlist_node **pprev = n-&gt;pprev;

	WRITE_ONCE(*pprev, next);
	if (next)
		WRITE_ONCE(next-&gt;pprev, pprev);
}
</code></pre><h1 id="ref">Ref</h1>
<p><a href="https://blog.csdn.net/weixin_39094034/article/details/104803967">https://blog.csdn.net/weixin_39094034/article/details/104803967</a></p>
<p><a href="https://linux.laoqinren.net/kernel/hlist/">https://linux.laoqinren.net/kernel/hlist/</a></p>

</main>
</div>

<br>

  <footer>
  <hr/>
  
  
  <hr/>
  © <a href="https://jaxwang28.github.io">Jackson Wang</a> 2022 &ndash; 2025 | <a href="https://github.com/jaxwang28">Github</a>
  
  </footer>
  </body>
</html>

