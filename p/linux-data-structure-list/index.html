<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Linux Kernel 数据结构分析之链表 | Jackson Blog</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="/css/github-markdown-light.css" />
    
<link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
<link rel="manifest" href="/favicon/site.webmanifest">


      <script async src="https://www.googletagmanager.com/gtag/js?id=7S26TLKGMX"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', '7S26TLKGMX');
        }
      </script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <meta name="referrer" content="no-referrer-when-downgrade">
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/post/">Posts</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/">RSS</a></li>
      
    </ul>
    <hr/>
    </nav>

<div style="margin-left: auto; margin-right: 0; text-align: right;" >
  📅
   2025/04/30 
  &nbsp

  <span id="busuanzi_container_page_pv">
  👀<span id="busuanzi_value_page_pv"></span>
  </span> 
</div>
<div class="markdown-box">
<main class="markdown-body">
<h1 id="linux-kernel-数据结构分析之链表">Linux Kernel 数据结构分析之链表</h1>
<p>Linux Kernel 中实现了以下两种链表：</p>
<ul>
<li>双向循环链表</li>
<li>hash 链表</li>
</ul>
<p>本文将分别分析两种链表的实现。</p>
<h2 id="一双向循环链表">一、双向循环链表</h2>
<p>Linux 使用了最简洁的方式实现了一个几乎是万能的链表，其通过将 <code>struct list_head</code> <strong>嵌入到其他结构体中</strong>，实现双向循环链表。并在 <code>include/linux/list.h</code> 定义了支持的所有操作。</p>
<pre><code class="language-C">// include/linux/types.h

struct list_head {
	struct list_head *next, *prev;
};
</code></pre>
<p>以 <code>keme_caches</code> 链表进行分析。</p>
<pre><code>// mm/slab_common.c

LIST_HEAD(slab_caches);
</code></pre>
<pre><code>// mm/slab.h

struct kmem_cache {
    ....
    struct list_head list;		/* List of slab caches */
    ....
}
</code></pre>
<center><img src="https://img.jaxwang.top/2025/04/c8590fa84ab49e876bb5296f2dc13712.png" width="70%" height="70%"> </center>
<p>上面的例子中，指针指向是 <code>struct kmem_cache</code> 中 <code>list</code> 成员。通过这个成员的地址获得 <code>struct kmem_cache</code> 的地址的操作，在 Linux 中通过 <code>list_entry</code> 实现。下面分析其实现逻辑。</p>
<pre><code>// include/linux/list.h

/**
 * list_entry - get the struct for this entry
 * @ptr:	the &amp;struct list_head pointer.
 * @type:	the type of the struct this is embedded in.
 * @member:	the name of the list_head within the struct.
 */
#define list_entry(ptr, type, member) \
	container_of(ptr, type, member)
</code></pre>
<pre><code>// include/linux/container_of.h

/**
 * container_of - cast a member of a structure out to the containing structure
 * @ptr:	the pointer to the member.
 * @type:	the type of the container struct this is embedded in.
 * @member:	the name of the member within the struct.
 *
 * WARNING: any const qualifier of @ptr is lost.
 */
#define container_of(ptr, type, member) ({				\
	void *__mptr = (void *)(ptr);					\
	static_assert(__same_type(*(ptr), ((type *)0)-&gt;member) ||	\
		      __same_type(*(ptr), void),			\
		      &quot;pointer type mismatch in container_of()&quot;);	\
	((type *)(__mptr - offsetof(type, member))); })
</code></pre>
<pre><code>// tools/include/linux/kernel.h

#ifndef offsetof
#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)
#endif
</code></pre>
<ol>
<li><code>offsetof</code> 计算结构体中某个成员的偏移量，其通过强转假设地址 0 处有一个 TYPE 类型的结构体，<code>-&gt;</code>指针取结构体成员 Member，最后通过 <code>&amp;</code> 获得 Member 的地址，并强转为 <code>size_t</code> 类型。</li>
<li><code>container_of</code> 利用成员指针，获得结构体的指针。<strong>成员指针 - 成员的偏移量=结构体指针</strong></li>
<li><code>list_entry</code> list_head 作为一个成员嵌入到结构体中，已知 list_head 指针，调用 <code>container_of</code> 获得结构体指针。</li>
</ol>
<h2 id="二hash-链表">二、hash 链表</h2>
<p>linux kernel 中定义 <code>hlist_head</code> 用作 hash 表中的链表头，<code>hlist_node</code> 用作链表中的某一项。</p>
<pre><code>// include/linux/types.h

struct hlist_head {
	struct hlist_node *first;
};

struct hlist_node {
	struct hlist_node *next, **pprev;
};
</code></pre>
<center><img src="https://img.jaxwang.top/2025/04/743a01bbad60899615e2f1507da5f383.png" width="70%" height="70%"></center>
<p>Linux kernel 设计 <code>hlist_head</code> 仅包含一个指针用作 hash_table 中的列表头，这样可以节省很大空间，特别是当 hash bucket 很大的时候，可以节省一半空间。</p>
<p>散列表的冲突情况很少，链表不会很长，遍历很快。将 <code>pprev</code> 设计为指向前一个节点的 <code>next</code> 很容易实现删除操作。</p>
<pre><code>// include/linux/list.h

static inline void __hlist_del(struct hlist_node *n)
{
	struct hlist_node *next = n-&gt;next;
	struct hlist_node **pprev = n-&gt;pprev;

	WRITE_ONCE(*pprev, next);
	if (next)
		WRITE_ONCE(next-&gt;pprev, pprev);
}
</code></pre>
<h1 id="ref">Ref</h1>
<p><a href="https://blog.csdn.net/weixin_39094034/article/details/104803967">https://blog.csdn.net/weixin_39094034/article/details/104803967</a></p>
<p><a href="https://linux.laoqinren.net/kernel/hlist/">https://linux.laoqinren.net/kernel/hlist/</a></p>

</main>
</div>

<br>

<script src="https://giscus.app/client.js"
        data-repo="JaxWang28/Blog"
        data-repo-id="R_kgDOIbrexg"
        data-category="Announcements"
        data-category-id="DIC_kwDOIbrexs4CSjN8"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
</script>

  <footer>
  <hr/>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="//cdn.jsdelivr.net/combine/npm/katex/dist/katex.min.js,npm/katex/dist/contrib/auto-render.min.js,npm/@xiee/utils/js/render-katex.js" defer></script>

<script src="//cdn.jsdelivr.net/npm/@xiee/utils/js/center-img.min.js" defer></script>


<div class="busuanzi-footer">
  <span id="busuanzi_container_site_pv">
    总访问量 <span id="busuanzi_value_site_pv"></span> 次
  </span>
  <span id="busuanzi_container_site_uv">
    访客数 <span id="busuanzi_value_site_uv"></span> 人次
  </span>
</div>
  
  <hr/>
  © <a href="https://jaxwang28.github.io">Jackson Wang</a> 2017 &ndash; 2025 | <a href="https://github.com/jaxwang28">Github</a>
  
  </footer>
  </body>
</html>

