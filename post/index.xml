<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Jackson Blog</title>
    <link>https://blog.jaxwang.top/post/</link>
    <description>Recent content in Posts on Jackson Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 30 Apr 2025 15:07:00 +0800</lastBuildDate>
    <atom:link href="https://blog.jaxwang.top/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux - 数据结构 - list</title>
      <link>https://blog.jaxwang.top/p/linux-data-structure-list/</link>
      <pubDate>Wed, 30 Apr 2025 15:07:00 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/linux-data-structure-list/</guid>
      <description>&lt;p&gt;Linux 中实现了双向循环链表，和 hash 链表。&lt;/p&gt;&#xA;&lt;h1 id=&#34;0x01-双向链表-list_head&#34;&gt;0x01 双向链表 list_head&lt;/h1&gt;&#xA;&lt;p&gt;Linux 使用了最简洁的方式实现了一个几乎是万能的链表，其通过将下面结构体嵌入到其他结构体中，实现双向循环链表。在 &lt;code&gt;include/linux/list.h&lt;/code&gt; 定义了支持的所有操作。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;include/linux/types.h&lt;/em&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;struct list_head {&#xA;&#x9;struct list_head *next, *prev;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;mm/slab_common.c&lt;/em&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;LIST_HEAD(slab_caches);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;em&gt;mm/slab.h&lt;/em&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;struct kmem_cache {&#xA;    ....&#xA;    struct list_head list;&#x9;&#x9;/* List of slab caches */&#xA;    ....&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2025/04/c8590fa84ab49e876bb5296f2dc13712.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;从上面的例子中，指针指向的都是 &lt;code&gt;struct kmem_cache&lt;/code&gt; 中 &lt;code&gt;list&lt;/code&gt; 成员的地址，如何通过这个成员获得 &lt;code&gt;struct kmem_cache&lt;/code&gt; 的地址，在 Linux 中称为 &lt;code&gt;list_entry&lt;/code&gt; 的操作，通过下面代码实现：&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;include/linux/list.h&lt;/em&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;/**&#xA; * list_entry - get the struct for this entry&#xA; * @ptr:&#x9;the &amp;amp;struct list_head pointer.&#xA; * @type:&#x9;the type of the struct this is embedded in.&#xA; * @member:&#x9;the name of the list_head within the struct.&#xA; */&#xA;#define list_entry(ptr, type, member) \&#xA;&#x9;container_of(ptr, type, member)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;em&gt;include/linux/container_of.h&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux - 内存管理 - 物理内存模型</title>
      <link>https://blog.jaxwang.top/p/linux-memory-physical-memory-model/</link>
      <pubDate>Tue, 29 Apr 2025 16:30:00 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/linux-memory-physical-memory-model/</guid>
      <description>&lt;p&gt;4GB RAM 4KB 页面大小的 Linux 系统会产生一百万之多的 &lt;code&gt;struct page&lt;/code&gt;，组织管理这些结构体的方式我们称为内存模型。Linux 目前支持两种模型：&lt;code&gt;FLATMEM&lt;/code&gt; &lt;code&gt;SPARSEMEM&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;无论选择哪个内存模型，都会通过&lt;strong&gt;一个或多个数组&lt;/strong&gt;管理 &lt;code&gt;struct page&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h1 id=&#34;内存空洞-memory-hole&#34;&gt;内存空洞 memory hole&lt;/h1&gt;&#xA;&lt;p&gt;事实上 RAM 只是物理地址空间的一部分，物理地址空间通常会出现一部分地址是不用做普通内存使用的，对于这地址我们称之为&lt;strong&gt;内存空洞 Memory Hole&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;使用 &lt;code&gt;qemu-system-x86_64 -m 8G &lt;/code&gt; 启动 Kernel，可以看到下面 log&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;[    0.000000] BIOS-provided physical RAM map:&#xA;[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usable&#xA;[    0.000000] BIOS-e820: [mem 0x000000000009fc00-0x000000000009ffff] reserved&#xA;[    0.000000] BIOS-e820: [mem 0x00000000000f0000-0x00000000000fffff] reserved&#xA;[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x00000000bffdffff] usable&#xA;[    0.000000] BIOS-e820: [mem 0x00000000bffe0000-0x00000000bfffffff] reserved&#xA;[    0.000000] BIOS-e820: [mem 0x00000000fffc0000-0x00000000ffffffff] reserved&#xA;[    0.000000] BIOS-e820: [mem 0x0000000100000000-0x000000023fffffff] usable&#xA;[    0.000000] BIOS-e820: [mem 0x000000fd00000000-0x000000ffffffffff] reserved&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;对于其中 &lt;code&gt;reserved&lt;/code&gt; 的部分是不可作为普通内存使用的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux - 内存管理 - 页描述符</title>
      <link>https://blog.jaxwang.top/p/linux-memory-page-descriptor/</link>
      <pubDate>Tue, 29 Apr 2025 16:25:00 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/linux-memory-page-descriptor/</guid>
      <description>&lt;p&gt;Linux 使用分页技术，因此对物理内存管理的基本单位是 &lt;strong&gt;Page Frame 页框&lt;/strong&gt;。Linux 必须对每一个 Page Frame 了如执掌，其通过为每个页框分配一个&lt;strong&gt;页描述符&lt;/strong&gt; &lt;code&gt;struct page&lt;/code&gt; 保存页框的基本信息。&lt;/p&gt;&#xA;&lt;p&gt;对于一个物理地址空间 4GB PAGE_SIZE=4KB Linux 系统，Linux 分配 &lt;code&gt;4GB/4KB = 1M = 2^20&lt;/code&gt; 大约一百万个 &lt;code&gt;struct page&lt;/code&gt; 结构体，尽管这是个庞大的数量，但这是不可避免的。&lt;/p&gt;&#xA;&lt;p&gt;这里我们可以得到一个对应关系:&#xA;&lt;img src=&#34;https://img.jaxwang.top/2025/04/b5b82570c1935e7949d19886729d2a67.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Linux 中定义了两个宏进行 PFN 与 &lt;code&gt;struct page&lt;/code&gt; 之间的转换：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;page_to_pfn&#xA;pfn_to_page&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这两个宏的具体实现依赖于 Linux 使用的物理内存模型，将在后文展开。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;include/linux/mm_types.h&lt;/em&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;/*&#xA; * Each physical page in the system has a struct page associated with&#xA; * it to keep track of whatever it is we are using the page for at the&#xA; * moment. Note that we have no way to track which tasks are using&#xA; * a page, though if it is a pagecache page, rmap structures can tell us&#xA; * who is mapping it.&#xA; */&#xA;struct page {&#xA;    ...&#xA;    unsigned long flags;&#xA;    ...&#x9;&#xA;} _struct_page_alignment;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Linux - 内存管理 - 分页虚拟存储理论</title>
      <link>https://blog.jaxwang.top/p/linux-memory-paging-fundamental/</link>
      <pubDate>Sat, 26 Apr 2025 14:37:06 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/linux-memory-paging-fundamental/</guid>
      <description>&lt;h1 id=&#34;0x00-很久之前&#34;&gt;0x00 很久之前&lt;/h1&gt;&#xA;&lt;p&gt;在很久之前，计算机使用单程序存储管理。&#xA;&lt;img src=&#34;https://img.jaxwang.top/2025/04/ff061f834f1d31c57ea6d8cdf56f5f5f.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在这种管理模式下，每次只能运行一个程序。操作系统每次将相应的程序从磁盘加载到 RAM 中。直至进程运行结束后跳转到操作系统代码，操作系统再根据用户需求将程序装入 RAM 中，覆盖掉旧的程序。存在问题：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一次只能运行一个程序&lt;/li&gt;&#xA;&lt;li&gt;进程（程序）的切换很慢&lt;/li&gt;&#xA;&lt;li&gt;程序的大小取决于 RAM 物理内存的大小&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;em&gt;事实上，后面又发展了多道程序，交换技术等技术来试图解决上述问题但效果不好，这里就不展开讲了，但为什么会讲一下单道存储管理，因为其与 Linux 虚拟存储空间布局很像，暂时无需知道什么是虚拟存储空间。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;0x01-虚拟存储器-virtual-memory&#34;&gt;0x01 虚拟存储器 Virtual Memory&lt;/h1&gt;&#xA;&lt;p&gt;虚拟存储技术发展的根本原因：&#xA;RAM 小且昂贵，无论是上世纪还是当下，RAM 都是小且昂贵的资源，所以我们不得不充分利用，进而发展出虚拟存储技术。假设我们的 RAM 可以无限大且廉价。&#xA;&lt;img src=&#34;https://img.jaxwang.top/2025/04/218c50bcec6a497456a3a8e11f1e4d1e.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;虚拟存储的基础及事实：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;局部性原理：程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。这也意味着并不需要完全把程序加载到 RAM 也能保证程序的执行。&lt;/li&gt;&#xA;&lt;li&gt;磁盘空间很大且足够便宜，可以把程序暂时不需要的那一部分放在磁盘上，把需要的那部分放在 RAM 上。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Virtual Memroy[1] 由 Fotheringham 在 1961 年提出[2]，其基本思想是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;程序的代码数据和栈的总大小可以超过物理内存（RAM）&lt;/li&gt;&#xA;&lt;li&gt;操作系统将正在运行的程序的需要的那部分保留在内存中，而将当前不使用的部分放置在磁盘上，根据需要调入内存。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2025/04/ad0efef73393d346579d2f240337f46a.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;根据虚拟存储器实现的技术可以分为：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;页式：采用 &lt;strong&gt;分页 Paging&lt;/strong&gt; 技术&lt;/li&gt;&#xA;&lt;li&gt;段式：采用 &lt;strong&gt;分段 Segmentation&lt;/strong&gt; 技术&lt;/li&gt;&#xA;&lt;li&gt;分页分段结合：Paged Segmentation&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;目前大多数虚拟存储管理系统都采用&lt;strong&gt;分页 paging&lt;/strong&gt; 技术，本文也仅讲解分页存储管理。&lt;/p&gt;&#xA;&lt;h1 id=&#34;0x02-分页基本思想&#34;&gt;0x02 分页基本思想&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将物理内存划分为为许多固定大小（&lt;strong&gt;PAGE SIZE&lt;/strong&gt;）的内存块 ，称为&lt;strong&gt;物理页面 页框 page frame&lt;/strong&gt;,并为每个页框从低地址开始编号称为&lt;strong&gt;PFN&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;将程序（用户程序和OS）中使用的地址称为&lt;strong&gt;虚拟地址&lt;/strong&gt;，并构成&lt;strong&gt;虚拟地址空间&lt;/strong&gt;。将虚拟地址空间划分为大小相同的块，称为&lt;strong&gt;虚拟页面 page&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;CPU 访问程序中使用的地址时，并不是放在地址总线上，而是被送往&lt;strong&gt;存储管理单元 MMU&lt;/strong&gt;，其利用映射关系（其实就是页表）将虚拟地址转化为物理地址后再进行访问。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux - 进程管理 - 进程描述符 - state</title>
      <link>https://blog.jaxwang.top/p/linux-progress-taskstruct-state/</link>
      <pubDate>Sun, 20 Apr 2025 17:26:06 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/linux-progress-taskstruct-state/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2025/04/36b9b75b2ec34273e0b4b59a2d746966.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;include/linux/sched.h&#xA;&#xA;struct task_struct {&#xA;    ....&#xA;&#x9;unsigned int __state;&#xA;&#x9;...&#xA;}&#xA;&#xA;/* Used in tsk-&amp;gt;__state: */&#xA;#define TASK_RUNNING            0x00000000&#xA;#define TASK_INTERRUPTIBLE      0x00000001&#xA;#define TASK_UNINTERRUPTIBLE    0x00000002&#xA;#define __TASK_STOPPED          0x00000004&#xA;#define __TASK_TRACED           0x00000008&#xA;/* Used in tsk-&amp;gt;exit_state: */&#xA;#define EXIT_DEAD               0x00000010&#xA;#define EXIT_ZOMBIE             0x00000020&#xA;#define EXIT_TRACE              (EXIT_ZOMBIE | EXIT_DEAD)&#xA;/* Used in tsk-&amp;gt;__state again: */&#xA;#define TASK_PARKED             0x00000040&#xA;#define TASK_DEAD               0x00000080&#xA;#define TASK_WAKEKILL           0x00000100&#xA;#define TASK_WAKING             0x00000200&#xA;#define TASK_NOLOAD             0x00000400&#xA;#define TASK_NEW                0x00000800&#xA;#define TASK_RTLOCK_WAIT        0x00001000&#xA;#define TASK_FREEZABLE          0x00002000&#xA;#define __TASK_FREEZABLE_UNSAFE (0x00004000 * IS_ENABLED(CONFIG_LOCKDEP))&#xA;#define TASK_FROZEN             0x00008000&#xA;#define TASK_STATE_MAX          0x00010000&#xA;#define TASK_ANY                (TASK_STATE_MAX-1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;State&lt;/th&gt;&#xA;          &lt;th&gt;Description&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TASK_RUNNING&lt;/td&gt;&#xA;          &lt;td&gt;可运行状态：进程要么在 CPU 上执行，要么准备执行&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TASK_INTERRUPTIBLE&lt;/td&gt;&#xA;          &lt;td&gt;可中断的等待状态：进程被挂起（睡眠），直到某个条件为真。产生硬件中断，释放进程等待的系统资源，或传递一个信号都可以唤起进程。进程唤起后状态回到 TASK_RUNNING&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TASK_UNINTERRUPTIBLE&lt;/td&gt;&#xA;          &lt;td&gt;不可中断的挂起状态：忽略任何信号。进程必须在不被打断的情况下等待某个事件的发生&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;__TASK_STOPPED&lt;/td&gt;&#xA;          &lt;td&gt;暂停状态：进程执行被暂停，进程收到 SIGSTOP SIGTTIN SIGTSTP SIGTTOU 信号后进入暂停状态&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;__TASK_TRACED&lt;/td&gt;&#xA;          &lt;td&gt;跟踪状态：进程的执行已由 debugger 程序暂停。当一个进程被另一个进程监控时，每一个信号都会让进程进入此状态&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;EXIT_ZOMBIE&lt;/td&gt;&#xA;          &lt;td&gt;僵死状态：进程的执行被终止，但是父进程还没有发布 &lt;code&gt;wait4()&lt;/code&gt; 和 &lt;code&gt;waitpid()&lt;/code&gt; 系统调用来返回有关死亡进程的信息。此时内核还不能丢弃死亡进程描述符中的数据，父进程还可能需要&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;EXIT_DEAD&lt;/td&gt;&#xA;          &lt;td&gt;僵死撤销状态：父进程刚发出 &lt;code&gt;wait4()&lt;/code&gt; &lt;code&gt;waitpid()&lt;/code&gt; 系统调用，进程由系统删除。为了防止其它执行线程在同一个进程上也执行 &lt;code&gt;wait()&lt;/code&gt; 类系统调用，把进程从 &lt;code&gt;EXIT_ZOMBIE&lt;/code&gt; 切换到 &lt;code&gt;EXIT_DEAD&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h1 id=&#34;ref&#34;&gt;Ref.&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://blog.jaxwang.top/p/linux-progress-taskstruct-state/&#34;&gt;https://blog.jaxwang.top/p/linux-progress-taskstruct-state/&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>x86 Linux 启动第二阶段 - protected mode</title>
      <link>https://blog.jaxwang.top/p/x86-linux-kernet-boot-setup/</link>
      <pubDate>Sun, 20 Apr 2025 11:04:06 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/x86-linux-kernet-boot-setup/</guid>
      <description>&lt;p&gt;bootloader 在将 kernel 加载到 &lt;code&gt;0x100000&lt;/code&gt; 后设置 &lt;code&gt;boot_params.hdr.code32_start&lt;/code&gt; ，这个地址 &lt;code&gt;protected_mode&lt;/code&gt; 内核的开始地址即 &lt;code&gt;0x100000&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;(gdb) x/32x 0x100000&#xA;0x100000:       0xfc    0xfa    0x8d    0xa6    0xe8    0x01    0x00    0x00&#xA;0x100008:       0xe8    0x00    0x00    0x00    0x00    0x5d    0x83    0xed&#xA;&#xA;readelf -x .head.text arch/x86/boot/compressed/vmlinux&#xA;0x00000000 fcfa8da6 e8010000 e8000000 005d83ed .............]..&#xA;0x00000010 0d8d8510 f0c90089 40020f01 10b81800 ........@.......&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;第一张全局描述符表-gdt&#34;&gt;第一张全局描述符表 GDT&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;SYM_DATA_START_LOCAL(gdt)&#xA;        .word   gdt_end - gdt - 1&#xA;        .long   0&#xA;        .word   0&#xA;        .quad   0x00cf9a000000ffff      /* __KERNEL32_CS */&#xA;        .quad   0x00af9a000000ffff      /* __KERNEL_CS */&#xA;        .quad   0x00cf92000000ffff      /* __KERNEL_DS */&#xA;        .quad   0x0080890000000000      /* TS descriptor */&#xA;        .quad   0x0000000000000000      /* TS continued */&#xA;SYM_DATA_END_LABEL(gdt, SYM_L_LOCAL, gdt_end)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2025/04/441e0ef44d4aa8bef05b2ab190446907.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>valgrind 交叉编译</title>
      <link>https://blog.jaxwang.top/p/valgrind-cross-compile/</link>
      <pubDate>Sat, 19 Apr 2025 21:45:06 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/valgrind-cross-compile/</guid>
      <description>&lt;h1 id=&#34;交叉编译&#34;&gt;交叉编译&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;指定 &lt;code&gt;toolchains&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;export GCC_PATH=/your_path_for_linaro/bin&#xA;export CC=${GCC_PATH}/aarch64-linux-gnu-gcc&#xA;export LD=${GCC_PATH}/aarch64-linux-gnu-ld&#xA;export AR=${GCC_PATH}/aarch64-linux-gnu-ar&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;编译配置&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;cd valgrind&#xA;./autogen.sh&#xA;./configure --prefix=`pwd`/Inst --host=aarch64-unknown-linux --enable-only64bit&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;编译安装&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;make -j4 install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;带调试信息的-libc&#34;&gt;带调试信息的 libc&lt;/h1&gt;&#xA;&lt;p&gt;valgrind 需要使用带调试信息的 &lt;code&gt;libc&lt;/code&gt;，否则会报 &lt;code&gt;cannot be set up&lt;/code&gt; 错误。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;libc&lt;/code&gt; 可以在交叉编译工具链中找到。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ find . -name &amp;quot;*ld*.so&amp;quot;&#xA;./aarch64-linux-gnu/libc/lib/ld-2.25.so&#xA;$ file ./aarch64-linux-gnu/libc/lib/ld-&#xA;ld-2.25.so             ld-linux-aarch64.so.1&#xA;$ file ./aarch64-linux-gnu/libc/lib/ld-2.25.so&#xA;./aarch64-linux-gnu/libc/lib/ld-2.25.so: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, BuildID[sha1]=73b23c16ff9fe3eab046636cd9dd6db9d3309f27, with debug_info, not stripped&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;启动&#34;&gt;启动&lt;/h1&gt;&#xA;&lt;p&gt;将编译产生的工具目录和 &lt;code&gt;libc&lt;/code&gt; 放入板子，启动 valgrind.&lt;/p&gt;</description>
    </item>
    <item>
      <title>x86 Linux 启动第一阶段 - setup</title>
      <link>https://blog.jaxwang.top/p/x86-linux-kernet-boot-setup/</link>
      <pubDate>Sat, 19 Apr 2025 20:45:06 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/x86-linux-kernet-boot-setup/</guid>
      <description>&lt;pre&gt;&lt;code&gt;linux-6.12.4&#xA;QEMU emulator version 8.2.2 (Debian 1:8.2.2+ds-0ubuntu1.6)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;魔数-mz&#34;&gt;魔数 MZ&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;readelf -x .bstext  arch/x86/boot/setup.elf&#xA;Hex dump of section &#39;.bstext&#39;:&#xA;0x00000000 4d5a0000 00000000 00000000 00000000 MZ..............&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;xxd arch/x86/boot/setup.bin&#xA;00000000: 4d5a 0000 0000 0000 0000 0000 0000 0000  MZ..............&#xA;00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;(gdb) hb *0x10200&#xA;(gdb) c&#xA;(gdb) x/2c 0x10000&#xA;0x10000 &amp;lt;exception_stacks+16384&amp;gt;:       77 &#39;M&#39;  90 &#39;Z&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;setup-过程函数跳转&#34;&gt;setup 过程函数跳转&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2025/04/1ea16f28231769c5f553393cfd522178.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;_start&#34;&gt;_start&lt;/h1&gt;&#xA;&lt;p&gt;bootloader 将 &lt;code&gt;setup.bin&lt;/code&gt; 加载到 &lt;code&gt;0x10000&lt;/code&gt; 地址处后，将 &lt;code&gt;CS&lt;/code&gt; 置为 &lt;code&gt;0x1020&lt;/code&gt; ，&lt;code&gt;IP&lt;/code&gt; 置为 &lt;code&gt;0x0&lt;/code&gt;。通过计算可以得知地址为 &lt;code&gt;0x10200&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>路由器硬件组成</title>
      <link>https://blog.jaxwang.top/p/router-hardware/</link>
      <pubDate>Sun, 24 Nov 2024 19:45:06 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/router-hardware/</guid>
      <description>&lt;p&gt;本文以 &lt;code&gt;Redmi AX6000&lt;/code&gt; 为例，介绍现代路由器中硬件组成，整理为以下部分：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPU&lt;/li&gt;&#xA;&lt;li&gt;RAM&lt;/li&gt;&#xA;&lt;li&gt;ROM Flash&lt;/li&gt;&#xA;&lt;li&gt;交换芯片&lt;/li&gt;&#xA;&lt;li&gt;RF 芯片&lt;/li&gt;&#xA;&lt;li&gt;FEM 芯片&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;重要网站：&lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;WikiDevi&lt;/strong&gt; is a user-editable database for computer hardware. &lt;a href=&#34;https://wikidevi.wi-cat.ru/&#34;&gt;https://wikidevi.wi-cat.ru/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;cpu&#34;&gt;CPU&lt;/h1&gt;&#xA;&lt;p&gt;目前主流的路由器芯片为 &lt;strong&gt;QualComm BraodCom MediaTek RealTek&lt;/strong&gt;。对于一款 CPU，尤其需要关注这些参数：&lt;strong&gt;型号、架构、核心数、制程、频率&lt;/strong&gt;。  &lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;Redmi AX6000 CPU 参数：&lt;br&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;型号：MediaTek MT7986A&lt;/li&gt;&#xA;&lt;li&gt;架构：ARM Cortex-A53&lt;/li&gt;&#xA;&lt;li&gt;核心数：4 核&lt;/li&gt;&#xA;&lt;li&gt;制程：12nm&lt;/li&gt;&#xA;&lt;li&gt;频率：2.0 GHz&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/11/593b4f15b720827f57cc27336a240a39.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;ram&#34;&gt;RAM&lt;/h1&gt;&#xA;&lt;p&gt;目前主流的 RAM 均为 Double Data Rate Synchronous Dynamic Random Access Memory，简称&lt;strong&gt;DDR SDRAM&lt;/strong&gt;或&lt;strong&gt;DDR&lt;/strong&gt;。关于 RAM 需要关注：&lt;strong&gt;类型、型号、容量、频率&lt;/strong&gt;。 &lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;Redmi AX6000 RAM 参数：&lt;br&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;类型：DDR3&lt;/li&gt;&#xA;&lt;li&gt;型号：K4A4G165WF-BCW&lt;/li&gt;&#xA;&lt;li&gt;容量：512 MB&lt;/li&gt;&#xA;&lt;li&gt;频率：3200 MHz&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/11/9372c151d96a21ba55fdf02e879fbde6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;rom-flash&#34;&gt;ROM Flash&lt;/h1&gt;&#xA;&lt;p&gt;Redmi AX6000 Flash 参数：&lt;br&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>RustDesk 自建服务器</title>
      <link>https://blog.jaxwang.top/p/rustdesk-server-oss/</link>
      <pubDate>Sat, 02 Nov 2024 18:11:54 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/rustdesk-server-oss/</guid>
      <description>&lt;p&gt;官方教程 RustDesk Server OSS - open source RustDesk Server. &lt;br&gt;&#xA;&lt;a href=&#34;https://rustdesk.com/docs/en&#34;&gt;https://rustdesk.com/docs/en&lt;/a&gt; &lt;br&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;rustdesk-框架&#34;&gt;RustDesk 框架&lt;/h1&gt;&#xA;&lt;h1 id=&#34;服务器端配置&#34;&gt;服务器端配置&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;下载 rustdesk server&#xA;Github  &lt;a href=&#34;https://github.com/rustdesk/rustdesk-server/releases&#34;&gt;https://github.com/rustdesk/rustdesk-server/releases&lt;/a&gt; &lt;br&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;生成密钥对&#xA;运行 &lt;code&gt;./hbbs&lt;/code&gt; 生成公钥私钥. &lt;br&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Systemd Service 配置&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;# /etc/systemd/system/hbbs.service&#xA;[Unit]&#xA;Description=RustDesk Server Service&#xA;After=network.target&#xA;&#xA;[Service]&#xA;Type=simple&#xA;User=root&#xA;# bin path&#xA;Restart=on-failure&#xA;RestartSec=5&#xA;WorkingDirectory=/home/jax/rustdesk&#xA;ExecStart=/home/jax/rustdesk/hbbs&#xA;&#xA;[Install]&#xA;WantedBy=multi-user.target&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;# /etc/systemd/system/hbbr.service&#xA;[Unit]&#xA;Description=RustDesk Server Service&#xA;After=network.target&#xA;&#xA;[Service]&#xA;Type=simple&#xA;User=root&#xA;# bin path&#xA;Restart=on-failure&#xA;RestartSec=5&#xA;WorkingDirectory=/home/jax/rustdesk&#xA;ExecStart=/home/jax/rustdesk/hbbr&#xA;&#xA;[Install]&#xA;WantedBy=multi-user.target&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;service hbbr start&#xA;service hbbs start&#xA;service hbbs status&#xA;service hbbr status&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;允许自动启动 &lt;br&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Makefile 杂记</title>
      <link>https://blog.jaxwang.top/p/makefile_note/</link>
      <pubDate>Sun, 20 Oct 2024 15:23:18 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/makefile_note/</guid>
      <description>&lt;p&gt;必须是 tab 不能是空格&lt;/p&gt;</description>
    </item>
    <item>
      <title>neovim 配置及使用</title>
      <link>https://blog.jaxwang.top/p/neovim-configuraion-usage/</link>
      <pubDate>Sun, 20 Oct 2024 15:17:52 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/neovim-configuraion-usage/</guid>
      <description>&lt;h1 id=&#34;0x01-install&#34;&gt;0x01 Install&lt;/h1&gt;&#xA;&lt;p&gt;Download Tarball 版本 &lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;Tarball 版本安装：&lt;br&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;mv /opt&#xA;ln -s /opt/nvim/bin/nvim /usr/local/bin/nvim&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;为什么使用 Tarball 版本？&lt;br&gt;&#xA;方便管理。&lt;br&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;0x02-基本设置&#34;&gt;0x02 基本设置&lt;/h1&gt;&#xA;&lt;h1 id=&#34;0x03-终端字体&#34;&gt;0x03 终端字体&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.nerdfonts.com&#34;&gt;https://www.nerdfonts.com&lt;/a&gt; &lt;br&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;0x04-lazy&#34;&gt;0x04 Lazy&lt;/h1&gt;&#xA;&lt;h1 id=&#34;0x05-插件&#34;&gt;0x05 插件&lt;/h1&gt;&#xA;&lt;h1 id=&#34;0x06-依赖&#34;&gt;0x06 依赖&lt;/h1&gt;</description>
    </item>
    <item>
      <title>The History of Wi-Fi</title>
      <link>https://blog.jaxwang.top/p/history_of_wifi/</link>
      <pubDate>Thu, 19 Sep 2024 09:29:34 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/history_of_wifi/</guid>
      <description>&lt;p&gt;802.11&#xA;802.11a&#xA;802.11b&#xA;802.11g&#xA;802.11n&#xA;802.11ac&#xA;802.11ax&#xA;802.11be&lt;/p&gt;</description>
    </item>
    <item>
      <title>无线通信理论概述</title>
      <link>https://blog.jaxwang.top/p/wifi-wireless-communication-fundamental/</link>
      <pubDate>Tue, 17 Sep 2024 22:04:00 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/wifi-wireless-communication-fundamental/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/06/14b3606032cb762104032bbfb6f75b50.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文以上图为核心，对学习 IEEE802.11 需要的通信理论进行概述，并不做细节讨论。 &lt;br&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;0x01-通信概述&#34;&gt;0x01 通信概述&lt;/h1&gt;&#xA;&lt;p&gt;在广义上，通信就是将信息从一个地方传递到另一个地方，如飞鸽传书。 &lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们将实现通信（信息传递）的需要的技术设备和传输媒介称为通信系统，大体上可分为四种：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有线模拟通信系统&lt;/li&gt;&#xA;&lt;li&gt;无线模拟通信系统&lt;/li&gt;&#xA;&lt;li&gt;有线数字通信系统&lt;/li&gt;&#xA;&lt;li&gt;无线数字通信系统&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;对于各类系统的差别即优缺点这里不做概述，毫无疑问，IEEE802.11 为无线数字通信系统。无论哪一种通信系统，其通信模型都是固定的，如下图。 &lt;br&gt;&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/09/61279aa89e8b1ad1e3ed96dfbada8540.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;0x02-收发机-tx-rx&#34;&gt;0x02 收发机 TX RX&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/09/dbc4e148fdfaf5e434890565ed97f54d.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;信源编码&lt;/strong&gt;是指对模拟信号信源进行数字化再进行进行压缩编码。&lt;br&gt;&#xA;&lt;strong&gt;信道编码&lt;/strong&gt;，信道中是存在噪声和干扰的，通过增加冗余信息，以便接收端进行纠错处理。&lt;br&gt;&#xA;&lt;strong&gt;交织&lt;/strong&gt;，为了解决连续误码的问题。&lt;br&gt;&#xA;&lt;strong&gt;脉冲成形&lt;/strong&gt;，数字信号要想在信道中传输，必须转化为合适的脉冲波形。&lt;br&gt;&#xA;&lt;strong&gt;调制&lt;/strong&gt;，上面概念可以不用理解，但是调制需要我们理解，因为 IEEE80211 在每一代 Wi-Fi 标准的主要升级都会通过增加调制阶数来实现速度提升的目的。&lt;strong&gt;将信息承载到满足信道要求的高频载波信号上的过程就是调制。&lt;/strong&gt;&lt;br&gt;&#xA;为什么需要调制？根据电磁波理论可知：&lt;strong&gt;天线尺寸为被辐射信号波长的十分之一或更大些，信号才能被有效地辐射&lt;/strong&gt;，如果不经过调制直接在空间发送这个单音信号，需要的天线尺寸至少要几公里，显而易见，实际上根本不可能制造出这样的天线。通过调制将信号频谱搬移到较高的频率范围，如图所示，这样信号就很容易以电磁波形式辐射出去。&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/09/064e0f7d8ae4c930330268fe030e906b.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;还可以通过调制把多路信号频谱搬移到不同的频率范围内，实现多路频分复用（FDM）。&lt;br&gt;&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/09/d0073d1473196440a838539e4686b7ce.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;0x03-无线信道&#34;&gt;0x03 无线信道&lt;/h1&gt;&#xA;&lt;p&gt;信道就是指信号传输的通道，传输媒介决定了信道的特性。对于无线信道而言，传输媒介为自由空间的电磁波。&lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;电磁波又称为电磁辐射，是能量的一种，是指同相振荡，且互相垂直的电场与磁场，在空间中以波的形式传递能量。&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/09/0a9e56e6fa965417ff16a4b746206543.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;电磁波伴随的电场方向，磁场方向，传播方向三者互相垂直。电磁波实际上分为电波和磁波，是二者的总称，但由于电场和磁场总是同时出现，同时消失，并相互转换，所以通常将二者合称为电磁波。&lt;strong&gt;无线电波（射频信号）是电磁波的一种。&lt;/strong&gt;&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/09/24787fe591e828a118b294ccdae3290d.webp&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;电磁波有三大属性，即&lt;strong&gt;振幅&lt;/strong&gt;（强度、光强）、&lt;strong&gt;频率&lt;/strong&gt;（波长）和&lt;strong&gt;波形&lt;/strong&gt;（频谱分布）。&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/09/9739b604660b07643f03b09599b388fa.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;射频信号始于发射机产生的交流电信号。&lt;/p&gt;&#xA;&lt;h1&gt;&lt;/h1&gt;&#xA;&lt;p&gt;高频信号在通过各种物理介质时，衰减速度一般比低频信号要快。原因有二，自由空间路径损耗；频率越高信号穿越障碍物的能力越差。&lt;/p&gt;&#xA;&lt;p&gt;损耗（衰减）&#xA;用于描述振幅或信号强度的降低。由于自由空间路径损耗的影响，射频信号也会随着距离的增大而减小。&lt;/p&gt;&#xA;&lt;p&gt;自由空间路径损耗 FSPL&#xA;即使没有障碍物，射频信号也会随着距离的增大而减小。这是由于波的自然展宽而引起的信号减弱，也称为波束发散 beam divergence。&lt;br&gt;&#xA;FSPL 可以通过&lt;strong&gt;6 dB&lt;/strong&gt;规则粗略估算，即&lt;strong&gt;距离每翻一倍，振幅将减少 6 db&lt;/strong&gt;。&lt;br&gt;&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/06/e503ef0b04a58dba1947b6602f0c6fb3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;多径&#xA;多径是一种传播现象，指的是信号沿两条或多条路径同时或相隔极短时间到达接收天线。&lt;br&gt;&#xA;&lt;strong&gt;多径对遗留的 802.11a/b/g 无线接口具有破坏性影响，对采用 MIMO 天线分集与最大合并 MCR 信号处理技术的 802.11ac 无线接口具有建设性影响。&lt;/strong&gt;&lt;br&gt;&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/06/3b0bac646faef2045c408753b7248cc6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;载波信号&lt;/strong&gt;&#xA;交流信号或直流信号本身不具备数据传输能力，但是如果信号发生很小的波动或变化，就能够将其解析出来。从而实现数据的收发，这种经过修改的信号称为载波信号。调整信号以产生载波信号的过程称为调制。&lt;br&gt;&#xA;通过对电波的振幅、频率、相位三个分量进行调制以产载h生载波信号。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;键控法&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;收发器必须对信号进行处理，以便接收端可以正确区分 0 和 1。这种操作信号以表示多个数据的方法称为键控法 keying method。键控法将信号转化为载波信号。&lt;br&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Wireless Collection</title>
      <link>https://blog.jaxwang.top/p/wireless_collection/</link>
      <pubDate>Mon, 16 Sep 2024 09:42:07 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/wireless_collection/</guid>
      <description>&lt;p&gt;Wireless 资料整理。&lt;br&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;website&#34;&gt;Website&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.wi-fi.org&#34;&gt;https://www.wi-fi.org&lt;/a&gt; &lt;br&gt;&#xA;Wi-Fi Alliance® is the worldwide network of companies that brings you Wi-Fi®, one of the world’s most valued communications technologies. Our vision is to connect everyone and everything, everywhere. &lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.ieee.org&#34;&gt;https://www.ieee.org&lt;/a&gt; &lt;br&gt;&#xA;The professional home for the engineering and technology community worldwide. &lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://wlanprofessionals.com&#34;&gt;https://wlanprofessionals.com&lt;/a&gt; &lt;br&gt;&#xA;Equipping &amp;amp; Connecting Wi-Fi Pros through our online resources and our annual conferences. &lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://mcsindex.com&#34;&gt;https://mcsindex.com&lt;/a&gt; &lt;br&gt;&#xA;Modulation and Coding Scheme Table &lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.rcrwireless.com&#34;&gt;https://www.rcrwireless.com&lt;/a&gt; &lt;br&gt;&#xA;Since 1982, RCR Wireless News has been providing wireless and mobile industry news, insights, and analysis to mobile and wireless industry professionals, decision makers, policy makers, analysts and investors. &lt;br&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[IEEE80211be] MLO: Multi-Link Aggregation Operation</title>
      <link>https://blog.jaxwang.top/p/ieee80211be-mlo-multi-link-operation/</link>
      <pubDate>Sun, 15 Sep 2024 22:12:02 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/ieee80211be-mlo-multi-link-operation/</guid>
      <description>&lt;h1 id=&#34;0x01-what-is-mlo&#34;&gt;0x01 What is MLO?&lt;/h1&gt;&#xA;&lt;p&gt;在 Wi-Fi6 中，STA 与 AP 之间只在 1 个频段上建立连接（2.4G、5G、6G）。这意味着其他频段没有被使用，这无疑是一种浪费。虽然现有的 Wi-Fi 技术可以在 2.4G 5G 6G 之间切换，但切换带来的延迟可达 100ms 。&lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;IEEE80211be Wi-Fi7 引入 MLO 多链路聚合技术，使 STA 与 AP 可以在多个频段上同时建立连接，改善数据传输。&lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/09/72ffdf6f9a6e7d2fca6f18df793211ca.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;通过在多个频段建立连接，MLO 可以带来&lt;strong&gt;更大的吞吐量、更低的延迟、更好的可靠性。&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;0x02-mlo-相关概念&#34;&gt;0x02 MLO 相关概念&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/09/0ab4ca892433da3b57a775822c26d5c3.png&#34; alt=&#34;&#34;&gt;&#xA;多链路设备的一个射频单元有至少两个以上的射频链路链接到空口，但对于LLC层仅只有一个MAC地址。相比于单链路设备，在射频链路上增加了冗余。设备根据使用场景与空口状态，进行不同链路的切换与协同，来保障数据能够更高效、更快速、低延迟地进行传输。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Link&lt;/strong&gt;&#xA;代表实际的连接。Link 有自己独立的 MAC 地址。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;MLD&lt;/strong&gt;&#xA;Multi-Link Device，支持 MLO Device。&lt;br&gt;&#xA;协议规定MLD的mac可以跟两个Link中的一个相同，也可以是另外不同的唯一地址。&lt;/p&gt;&#xA;&lt;h1 id=&#34;0x03-asynchronous-and-synchronous&#34;&gt;0x03 asynchronous and synchronous&lt;/h1&gt;&#xA;&lt;p&gt;同步多链路传输，MLD 在多条 link 上同步传输帧，起始时间对齐。&lt;br&gt;&#xA;异步多链路传输，MLD 在多条 link 上异步传输帧，起始时间不对齐。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/09/a094dc352d15db23469ab8eb358b470e.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/09/fdb1f9b0da76c5e0e671808954a29615.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;采用异步多链路时，每条链路的传输独立，互不影响，&lt;code&gt;STR&lt;/code&gt; 工作模式被提出。&lt;br&gt;&#xA;但是当每个 link 所在的 Radio 没有充分隔离时，其中一条 link 的传输势必会对另一条 link 产生干扰，这种干扰为 &lt;code&gt;in-device conxextence(IDC)&lt;/code&gt; 干扰。为了解决这个问题，采用同步多链路的 &lt;code&gt;Non-STR(NSTR)&lt;/code&gt; 工作模式被提出。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[IEEE80211] Channel Switch Announcement</title>
      <link>https://blog.jaxwang.top/p/ieee80211-vhannel-switch-announcement/</link>
      <pubDate>Fri, 13 Sep 2024 22:31:03 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/ieee80211-vhannel-switch-announcement/</guid>
      <description>&lt;h1 id=&#34;0x01-简介&#34;&gt;0x01 简介&lt;/h1&gt;&#xA;&lt;p&gt;为了保持更好的连续性，AP 应该在其将要更换 Channel 时，通知连接在其上面的 Stas。&lt;/p&gt;&#xA;&lt;h1 id=&#34;0x02-实现&#34;&gt;0x02 实现&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;  AP -------------channel 52------------- Client&#xA;  |&#xA;  |  will change to ch40&#xA;  V&#xA;  AP -------------channel 52------------- Client&#xA;  |   ---- Send new channel/bandwidth----&amp;gt;   |  stop tx prepare to change&#xA;  |                                          |&#xA;  |                                          |&#xA;  |  CSA count down to 1,                    |  CSA count down to 1,&#xA;  V  change to new channel                   V  change to new channel   &#xA;  AP -------------channel 40------------- Client&#xA;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;通过在 &lt;strong&gt;Beacon 帧&lt;/strong&gt; 和 &lt;strong&gt;Probe Response 帧&lt;/strong&gt; 中添加 &lt;strong&gt;Channel Switch Announcement elements&lt;/strong&gt; 来实现此功能。&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/09/9cfdc5379d31491d23d9c99252c49c59.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[IEEE80211] Automatic Channel Selection</title>
      <link>https://blog.jaxwang.top/p/ieee80211-automatic-channel-selection/</link>
      <pubDate>Fri, 13 Sep 2024 22:13:36 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/ieee80211-automatic-channel-selection/</guid>
      <description>&lt;h1 id=&#34;0x01-简介&#34;&gt;0x01 简介&lt;/h1&gt;&#xA;&lt;p&gt;Automatic Channel Selection, 简称 ACS，也可以称为 Dynamic Channel Selection。是 Wi-Fi 的一个功能特性，其允许 AP 自动扫描并选择质量最好的 channel。&lt;/p&gt;&#xA;&lt;h1 id=&#34;0x02-意义&#34;&gt;0x02 意义&lt;/h1&gt;&#xA;&lt;p&gt;ACS 主要有两大意义：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;改善 Wi-Fi 质量。通过选择质量最好的 Channel，提高吞吐量。&lt;/li&gt;&#xA;&lt;li&gt;简化部署。部署 Wi-Fi 无线网络无需考虑 Channel 设定。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;0x03-实现&#34;&gt;0x03 实现&lt;/h1&gt;&#xA;&lt;p&gt;通过额外的天线扫描空气中 Wi-Fi 以及其他射频干扰，根据适当的算法，对不同 Channel 进行评估。&lt;/p&gt;</description>
    </item>
    <item>
      <title>EAP-Extensible Authentication Protocol</title>
      <link>https://blog.jaxwang.top/p/extensible-authentication-protocol/</link>
      <pubDate>Thu, 05 Sep 2024 23:53:25 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/extensible-authentication-protocol/</guid>
      <description>&lt;h1 id=&#34;0x00-eap-框架协议&#34;&gt;0x00 EAP 框架协议&lt;/h1&gt;&#xA;&lt;p&gt;Extensible Authentication Protocol 可扩展身份验证协议&lt;/p&gt;&#xA;&lt;p&gt;EAP 被设计用来在网络中进行身份验证，但其不适用于 IP 层。&#xA;EAP 是一种&lt;strong&gt;框架协议&lt;/strong&gt;，其本身并未规定如何进行身份验证，但其允许设计人员打造自己的 EAP 身份验证方式 EAP method。其在设计上能够运行于任何&lt;strong&gt;链路层&lt;/strong&gt;，但其不适用于 IP 层。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt; +-+-+-+-+-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+-+-+-+-+&#xA; |           |           |  |           |           |&#xA; | EAP method| EAP method|  | EAP method| EAP method|&#xA; | Type = X  | Type = Y  |  | Type = X  | Type = Y  |&#xA; |       V   |           |  |       ^   |           |&#xA; +-+-+-+-!-+-+-+-+-+-+-+-+  +-+-+-+-!-+-+-+-+-+-+-+-+&#xA; |       !               |  |       !               |&#xA; |  EAP  ! Peer layer    |  |  EAP  ! Auth. layer   |&#xA; |       !               |  |       !               |&#xA; +-+-+-+-!-+-+-+-+-+-+-+-+  +-+-+-+-!-+-+-+-+-+-+-+-+&#xA; |       !               |  |       !               |&#xA; |  EAP  ! layer         |  |  EAP  ! layer         |&#xA; |       !               |  |       !               |&#xA; +-+-+-+-!-+-+-+-+-+-+-+-+  +-+-+-+-!-+-+-+-+-+-+-+-+&#xA; |       !               |  |       !               |&#xA; | Lower ! layer         |  | Lower ! layer         |&#xA; |       !               |  |       !               |&#xA; +-+-+-+-!-+-+-+-+-+-+-+-+  +-+-+-+-!-+-+-+-+-+-+-+-+&#xA;         !                          !&#xA;         !   Peer                   ! Authenticator&#xA;         +------------&amp;gt;-------------+&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;0x01-封包格式&#34;&gt;0x01 封包格式&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt; 0                   1                   2                   3&#xA; 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1&#xA;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&#xA;|     Code      |  Identifier   |            Length             |&#xA;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&#xA;|    Data ...&#xA;+-+-+-+-+&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Code&#xA;1 Request&#xA;2 Response&#xA;3 Success&#xA;4 Failure&lt;/p&gt;</description>
    </item>
    <item>
      <title>WSL2 Kernel 升级更换</title>
      <link>https://blog.jaxwang.top/p/wsl2-kernel-update/</link>
      <pubDate>Wed, 14 Aug 2024 11:04:51 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/wsl2-kernel-update/</guid>
      <description>&lt;p&gt;&lt;strong&gt;! Warning&lt;/strong&gt;&lt;br&gt;&#xA;If you have multiple distros installed, they will all use the same kernel.&lt;br&gt;&#xA;WSL2 中不同发行版使用的是同一个内核。&lt;br&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;0x01-准备&#34;&gt;0x01 准备&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;源码&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/microsoft/WSL2-Linux-Kernel.git&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;toolchain&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt update &amp;amp;&amp;amp; sudo apt install build-essential flex bison libssl-dev libelf-dev bc python3 pahole&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;查看源码分支选择版本&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 查看所有版本&#xA;git tag &#xA;&#xA;# 选择目前最新版本&#xA;git checkout linux-msft-wsl-6.6.36.3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;0x02-构建&#34;&gt;0x02 构建&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;make menuconfig KCONFIG_CONFIG=Microsoft/config-wsl&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;make -j$(nproc) KCONFIG_CONFIG=Microsoft/config-wsl&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;0x03-安装&#34;&gt;0x03 安装&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo make modules_install headers_install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;cp arch/x86/boot/bzImage /mnt/c/User/&amp;lt;username&amp;gt;/bzImage&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;创建 &lt;code&gt;%USERPROFILE%\.wslconfig&lt;/code&gt; 并添加下面内容&lt;/p&gt;</description>
    </item>
    <item>
      <title>OpenWRT ubus 框架</title>
      <link>https://blog.jaxwang.top/p/openwrt-ubus/</link>
      <pubDate>Sun, 28 Jul 2024 20:47:05 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/openwrt-ubus/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://openwrt.org/docs/techref/ubus&#34;&gt;https://openwrt.org/docs/techref/ubus&lt;/a&gt; &lt;br&gt;&#xA;&lt;a href=&#34;https://hackmd.io/@rYMqzC-9Rxy0Isn3zClURg/H1BY98bRw&#34;&gt;https://hackmd.io/@rYMqzC-9Rxy0Isn3zClURg/H1BY98bRw&lt;/a&gt; &lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;一直在使用 ubus，系统性学习一下，并准备用 rust 重构一把。&lt;/p&gt;&#xA;&lt;h1 id=&#34;ubus-概述&#34;&gt;ubus 概述&lt;/h1&gt;&#xA;&lt;p&gt;ubus 是一个 OpenWRT 中的 RPC 工具，其主要目的就是提供系统级进程间通信。&lt;br&gt;&#xA;其核心是 ubusd daemon，提供接口给任何其他 daemon 程序进行注册或发送信息。该接口使用 unix socket 实现，并使用 TLV 格式消息。&lt;br&gt;&#xA;ubus 提供了 3 种工具：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;libubus&lt;/li&gt;&#xA;&lt;li&gt;command-line tool ubus&lt;/li&gt;&#xA;&lt;li&gt;ubus lua module&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;ubus-通信模型&#34;&gt;ubus 通信模型&lt;/h1&gt;&#xA;&lt;p&gt;先看一下我们常见的 client-server 模型。&lt;br&gt;&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/07/c22c0e7464b519259d48e4ebc919159c.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;假设有 n 个程序，那么进程间通信的总 IPC 连接数将达到 n 的累加，这是非常惊人的数量。&lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;使用 ubus IPC 模型。&lt;br&gt;&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/07/337b7ddfd0334542f502db331c62f034.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;ubus daemon&lt;/strong&gt;：作为代理人，负责转发注册。&lt;br&gt;&#xA;&lt;strong&gt;ubus server object&lt;/strong&gt;：一些软件或守护进程提供接口，供其他软件调用。Server object 以及其注册的方法可以被 client 调用。&lt;br&gt;&#xA;&lt;strong&gt;ubus client object&lt;/strong&gt;：调用者。&lt;br&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;ubus-工作模式&#34;&gt;ubus 工作模式&lt;/h1&gt;&#xA;&lt;h2 id=&#34;invoke&#34;&gt;Invoke&lt;/h2&gt;&#xA;&lt;p&gt;一对一的通信模式。&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/07/7f0b542ed8e100a5d92fe23e8849761f.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/07/a9062b48edd65822cecef2a0950fb7ab.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;subscribenotify&#34;&gt;Subscribe/notify&lt;/h2&gt;&#xA;&lt;p&gt;一对多的通信模式，以 object 进行分组。&lt;br&gt;&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/07/b3b08c141488348f69b93a602dd9a366.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>OpenWRT 构建 Rust Package</title>
      <link>https://blog.jaxwang.top/p/openwrt-rust-package-build/</link>
      <pubDate>Sun, 28 Jul 2024 11:29:49 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/openwrt-rust-package-build/</guid>
      <description>&lt;h1 id=&#34;openwrt-构建系统搭建&#34;&gt;OpenWRT 构建系统搭建&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;源码下载&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;git clone  https://github.com/openwrt/openwrt.git&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;版本更改&#xA;OpenWRT 从 &lt;a href=&#34;https://openwrt.org/releases/23.05/notes-23.05.0&#34;&gt;23.05.0&lt;/a&gt; 提供了 Rust Package Support&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;git checkout v23.05.4&#xA;# clean&#xA;make distclean&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;package 安装&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;./scripts/feeds update -a&#xA;./scripts/feeds install -a&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;ls ls feeds/packages/lang/rust/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;构建交叉编译环境配置文件&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;make menuconfig&#xA;勾选 Languages-&amp;gt;rust&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol start=&#34;5&#34;&gt;&#xA;&lt;li&gt;编译交叉工具链&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;make toolchain/install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol start=&#34;6&#34;&gt;&#xA;&lt;li&gt;调整 PATH 环境变量 目标无关工具和工具链被部署到 &lt;code&gt;staging_dir/host/&lt;/code&gt; 和 &lt;code&gt;staging_dir/toolchain/&lt;/code&gt; 目录。&lt;code&gt;staging_dir/host/bin&lt;/code&gt; 可以找到相关的可执行文件。我们将其添加到 PATH 环境变量中方便我们直接使用。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;export PATH=/home/buildbot/source/staging_dir/host/bin:$PATH&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;源码准备&#34;&gt;源码准备&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在 openwrt 的源码目录下执行&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;cargo new helloworld-rs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;创建-package&#34;&gt;创建 package&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在 openwrt source code 下创建一个 feed 仓库，并创建一个 examples 类别。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;mkdir -p mypackages/examples&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;向该仓库中添加个一 helloworld-rs package&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;cd mypackages/examples&#xA;mkdir helloworld-rs&#xA;touch Makefile&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;每一个 package 都需要一个 Package Manifest 来描述这个 package，如从何处下载源码，如何构建源码。使用下面 Makefile 来实现，其中 SOURCE_DIR 就表明了获取源码的途径。&lt;/p&gt;</description>
    </item>
    <item>
      <title>OpenWRT 构建个人 Package</title>
      <link>https://blog.jaxwang.top/p/openwrt-new-package-build/</link>
      <pubDate>Sat, 27 Jul 2024 18:30:52 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/openwrt-new-package-build/</guid>
      <description>&lt;p&gt;最权威官方指导： &lt;a href=&#34;https://openwrt.org/docs/guide-developer/helloworld/start&#34;&gt;https://openwrt.org/docs/guide-developer/helloworld/start&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;openwrt-编译系统准备&#34;&gt;OpenWRT 编译系统准备&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;源码下载&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;git clone  https://github.com/openwrt/openwrt.git&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;版本更改&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;git checkout v23.05.4&#xA;make distclean&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;安装更新 feeds 避免后面出现问题&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;./scripts/feeds update -a&#xA;./scripts/feeds install -a&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;配置交叉编译环境&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;make menuconfig&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol start=&#34;5&#34;&gt;&#xA;&lt;li&gt;编译交叉工具链&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;make toolchain/install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol start=&#34;6&#34;&gt;&#xA;&lt;li&gt;调整 PATH 环境变量&#xA;目标无关工具和工具链被部署到 &lt;code&gt;staging_dir/host/&lt;/code&gt; 和 &lt;code&gt;staging_dir/toolchain/&lt;/code&gt; 目录。&lt;code&gt;staging_dir/host/bin&lt;/code&gt; 可以找到相关的可执行文件。我们将其添加到 PATH 环境变量中方便我们直接使用。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;export PATH=/home/buildbot/source/staging_dir/host/bin:$PATH&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;源码准备&#34;&gt;源码准备&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在 openwrt 的源码目录创建一个 &lt;code&gt;helloworld&lt;/code&gt; 目录，并创建 &lt;code&gt;helloworld.c&lt;/code&gt; 文件。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;mkdir helloworld&#xA;touch helloworld.c&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;helloworld.c 如下&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;&#xA; &#xA;int main(void)&#xA;{&#xA;    printf(&amp;quot;\nHello, world!\n\n&amp;quot;);&#xA;&#x9;return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;创建-package&#34;&gt;创建 package&lt;/h1&gt;&#xA;&lt;p&gt;OpenWRT 高度依赖 &lt;strong&gt;package&lt;/strong&gt; 的概念，几乎所有软件都是从 package 而来，包括交叉编译工具甚至是 kernel。&lt;br&gt;&#xA;而 &lt;strong&gt;feed&lt;/strong&gt; 是一个包含多个软件包的集合。它类似于一个软件仓库，提供各种可安装的软件包和依赖项。它本质上就是一个仓库，可以是本地的，也可以是网络上的，例如 Github。&lt;/p&gt;</description>
    </item>
    <item>
      <title>无线通信理论基础（四）</title>
      <link>https://blog.jaxwang.top/p/wifi-wireless-communication-fundamental-4/</link>
      <pubDate>Sun, 30 Jun 2024 21:32:20 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/wifi-wireless-communication-fundamental-4/</guid>
      <description>&lt;p&gt;各种传输技术和频率范围。&lt;br&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;窄带与扩频&#34;&gt;窄带与扩频&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/06/13e863e07b7ef254346f03794ad711df.png&#34; alt=&#34;&#34;&gt;&lt;br&gt;&#xA;射频传输的方式主要分为窄带 narrowband 和扩频 spread spectrum。&lt;br&gt;&#xA;窄带：使用极窄的带宽发送携带数据。&lt;br&gt;&#xA;扩频：使用超出实际所需的带宽发送数据。&lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;扩频技术主要有两种：FH 和 DS&lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;多径干扰&lt;/strong&gt;&lt;br&gt;&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/06/3b0bac646faef2045c408753b7248cc6.png&#34; alt=&#34;&#34;&gt;&#xA;主信号与反射信号之间的延迟称为时延扩展 delay spread，如果时延扩展过大，反射信号可能干扰主信号的同一数据流，这种情况称为符号间干扰 ISI。&lt;br&gt;&#xA;扩频系统不易受到多径的干扰，因为扩频将信号扩展到更大的频率范围，不同频率在多径内产生的延迟不同，某些波长可能受干扰，其他波长不受干扰，因此优于窄带。&lt;br&gt;&#xA;在 802.11n/ac 出现之前多径一直是影响无线局域网的性能和吞吐量的因素。&lt;br&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;dsss-直接序列扩频&#34;&gt;DSSS 直接序列扩频&lt;/h2&gt;&#xA;&lt;p&gt;802.11 和 802.11b&lt;br&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;fhss-跳频扩频&#34;&gt;FHSS 跳频扩频&lt;/h2&gt;&#xA;&lt;p&gt;IEEE 802.11-2016 已经弃用 FHSS，不再赘述。蓝牙使用 FHSS。&lt;br&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;ofdm-正交频分复用&#34;&gt;OFDM 正交频分复用&lt;/h1&gt;&#xA;&lt;h1 id=&#34;ofdma-正交频分多址&#34;&gt;OFDMA 正交频分多址&lt;/h1&gt;&#xA;&lt;p&gt;是 OFDM 的多用户版本，目前 802.11a/g/n/ac 采用 OFDM 技术，通过 WiFi 频段进行单用户传输。&lt;br&gt;&#xA;而 OFDMA 将信道细分为较小的频率配置-资源单元 RU，以便同时进行多用户传输。例如可以将传统的 20 MHz 信道最多可以划分为 9 条较小的信道，每一条信道由一组 OFDM 副载波构成。&lt;br&gt;&#xA;802.11ax 将探讨 OFDMA 技术。&lt;br&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;工业科学和医疗频段-ism&#34;&gt;工业、科学和医疗频段 ISM&lt;/h1&gt;&#xA;&lt;p&gt;ISM 是国际电信联盟电信标准化部门定义的免授权频段，范围如下：&lt;br&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;902 MHz to 928 MHz (26 MHz wide)&lt;/li&gt;&#xA;&lt;li&gt;2.4 GHz to 2.5 GHz (100 MHz wide)&lt;/li&gt;&#xA;&lt;li&gt;5.725 GHz to 5.875 GHz (150 MHz wide)&#xA;&lt;em&gt;尽管是面授权，但是该频段的使用各个国家的规定是不同的。&lt;/em&gt;&lt;br&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;非授权国家信息基础设施频段-u-nii&#34;&gt;非授权国家信息基础设施频段 U-NII&lt;/h1&gt;&#xA;&lt;p&gt;U-NII 频段：802.11a 修正案规定，无线局域网可以使用 3 个 5GHz 频段传输数据，每个频段包含 4 条信道。这三个频段称为 U-NII 频段。&lt;br&gt;&#xA;802.11a 将 U-NII 频段划分为 3 组：&lt;br&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>无线通信理论基础（三）</title>
      <link>https://blog.jaxwang.top/p/wifi-wireless-communication-fundamental-3/</link>
      <pubDate>Sat, 29 Jun 2024 21:32:20 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/wifi-wireless-communication-fundamental-3/</guid>
      <description>&lt;h1 id=&#34;天线类型&#34;&gt;天线类型&lt;/h1&gt;&#xA;&lt;p&gt;天线不仅可以作为辐射器聚焦发射信号能量，还可以聚焦接收信号能量。&lt;br&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;全向天线&#34;&gt;全向天线&lt;/h2&gt;&#xA;&lt;p&gt;omnidirectional antenna&lt;br&gt;&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/06/8d67a716318a0407ad4e64bbccff2bf1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;半定向天线&#34;&gt;半定向天线&lt;/h2&gt;&#xA;&lt;p&gt;semidirectional antenna&lt;br&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;强方向性天线&#34;&gt;强方向性天线&lt;/h2&gt;&#xA;&lt;p&gt;highly directional antenna&lt;br&gt;&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/06/2ab3b010ce0c5ac82c7f77835711222c.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;天线分集&#34;&gt;天线分集&lt;/h1&gt;&#xA;&lt;p&gt;室内无线网络容易产生多径信号，为了补偿多径带来的影响，接入点等无线网络设备普遍采用天线分集 antenna diversity，又称为 spatial diversity，接入点使用两副或多副天线，并与接收机共同工作，以最大限度减少多径的不利影响。&lt;br&gt;&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/06/2477ab1897b0bffc445f4c20a0348d09.png&#34; alt=&#34;&#34;&gt;&#xA;接入点侦听到射频信号时，比较两副天线收到的信号，选择信号强的那副天线来接收数据帧。&lt;br&gt;&#xA;802.11n 之前的接口大多采用交换分集 switched diversity ，选择振幅最大的信号，忽略其他信号。&lt;br&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;多输入输出&#34;&gt;多输入输出&lt;/h1&gt;&#xA;&lt;p&gt;多输入多输出 MIMO 是一种更为复杂的&lt;strong&gt;天线分集&lt;/strong&gt;技术。&lt;br&gt;&#xA;多径会影响信号质量，因此传统的天线系统致力于消除多径带来的不利影响；而 MIMO 恰恰相反，它利用多径来改善信号质量，MIMO 使用多副天线同时收发数据，发射机能同时使用多个射频信号发射数据，接收机再将这些数据从信号中恢复。&lt;br&gt;&#xA;802.11n/ac 无线接口使用 MIMO。&lt;/p&gt;</description>
    </item>
    <item>
      <title>无线通信理论基础（二）</title>
      <link>https://blog.jaxwang.top/p/wifi-wireless-communication-fundamental-2/</link>
      <pubDate>Thu, 20 Jun 2024 21:48:59 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/wifi-wireless-communication-fundamental-2/</guid>
      <description>&lt;h1 id=&#34;射频组件&#34;&gt;射频组件&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/06/14b3606032cb762104032bbfb6f75b50.png&#34; alt=&#34;&#34;&gt;&lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Transmitter&lt;/strong&gt;&lt;br&gt;&#xA;发射机，用来产生特定频率的信号。&lt;br&gt;&#xA;&lt;strong&gt;Antenna&lt;/strong&gt;&lt;br&gt;&#xA;在通信系统中，与发射机相连的天线用来辐射信号，与接收机相连的天线用来捕捉信号。&lt;br&gt;&#xA;可以通过两种方式增加天线的功率输出，一种是增加发射机的功率，另一种是引导或聚焦天线辐射出去的射频信号。&lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Receiver&lt;/strong&gt;&lt;br&gt;&#xA;接收机，用来接收信号。&lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;发射机和接收机通常是一个设备，称为收发器 transceiver&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;功率单位与比较单位&#34;&gt;功率单位与比较单位&lt;/h1&gt;&#xA;&lt;p&gt;功率单位无需多言，就是描述功率的；比较单位是用来描述变化的，生活中最常见的比较单位（折扣），即 1 折，表示是原来的十分之一。&lt;br&gt;&#xA;常见的功率单位：&lt;br&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;瓦特(W)&lt;/li&gt;&#xA;&lt;li&gt;毫瓦(mW)&lt;/li&gt;&#xA;&lt;li&gt;毫瓦分贝(dBm)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;常见的比价单位：&lt;br&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分贝(dB)&lt;/li&gt;&#xA;&lt;li&gt;各向同性分贝(dBi)&lt;/li&gt;&#xA;&lt;li&gt;偶极子分贝(dBd)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;分贝&#34;&gt;分贝&lt;/h2&gt;&#xA;&lt;p&gt;一个比较单位，来自贝尔实验室，他们功率之比为 10:1 的声音信号称为 1 贝尔 Bell。100:1 为 2 贝尔，依次类推。&lt;br&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;10        lg10=1&#xA;100       lg100=2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;假设两功率 P1 与 P2&lt;br&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;1 B = 10 dB&#xA;P1 与 P2 的变化值为:&#xA;lg(P1/P2) B = 10 lg(P1/P2) dB&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;假设一个信号衰减 20 dB，计算其衰减倍数:&lt;br&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;10 lg(P1/P2) = 20&#xA;P1/P2 = 100&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;毫瓦分贝&#34;&gt;毫瓦分贝&lt;/h2&gt;&#xA;&lt;p&gt;毫瓦分贝指的是&lt;strong&gt;相对 1 mW 的分贝&lt;/strong&gt;。&lt;br&gt;&#xA;因此 0 毫瓦分贝指的是，相对 1 mW 的分贝数，即与 1 mW 为 1:1，因此&lt;br&gt;&#xA;假设一功率 P&lt;br&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>无线通信理论基础（一）</title>
      <link>https://blog.jaxwang.top/p/wifi-wireless-communication-fundamental-1/</link>
      <pubDate>Wed, 19 Jun 2024 23:29:42 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/wifi-wireless-communication-fundamental-1/</guid>
      <description>&lt;p&gt;学习 WiFi 需要一些基础无线通信理论。&lt;br&gt;&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/06/14b3606032cb762104032bbfb6f75b50.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;射频信号&#34;&gt;射频信号&lt;/h1&gt;&#xA;&lt;p&gt;发射机产生的交流电信号为射频信号。&lt;/p&gt;&#xA;&lt;h2 id=&#34;射频信号的特性&#34;&gt;射频信号的特性&lt;/h2&gt;&#xA;&lt;p&gt;波长频率振幅这里就不过多讲述了。&lt;br&gt;&#xA;相位并不是单一射频信号的特性，其是一个&lt;strong&gt;相对&lt;/strong&gt;概念，描述的是两个信号之间的关系。这和我们的月相是类似的。&lt;strong&gt;相位对理解多径 multipath 至关重要&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;射频信号的行为&#34;&gt;射频信号的行为&lt;/h2&gt;&#xA;&lt;p&gt;射频信号在空气中传播千变万化，射频的传播行为有以下几种关键的行为：吸收、反射、散射、折射、衍射、衰减、自由空间路径损耗、多径、增益。下面重点讲几种&lt;br&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;衰减&#34;&gt;衰减&lt;/h3&gt;&#xA;&lt;p&gt;信号在空间中传输，受吸收、距离和多径的影响而衰减。&lt;/p&gt;&#xA;&lt;h3 id=&#34;自由空间路径损耗&#34;&gt;自由空间路径损耗&lt;/h3&gt;&#xA;&lt;p&gt;即使没有障碍吸收和多径的影响，电磁信号在传输中也会受物理定律而衰弱。射频信号在离开天线之后，能量会扩散到更大的区域，导致信号强度减弱。&lt;br&gt;&#xA;这里讲一下 6dB 规则，即距离每增加 1 倍，振幅将减少 6dB。如图中 2000 到 4000，增加 1 倍之后，振幅减少 6dB。&lt;br&gt;&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/06/e503ef0b04a58dba1947b6602f0c6fb3.png&#34; alt=&#34;&#34;&gt;&lt;br&gt;`&lt;/p&gt;&#xA;&lt;h3 id=&#34;多径&#34;&gt;多径&lt;/h3&gt;&#xA;&lt;p&gt;由于信号会发生反射、散射、折射或衍射，导致同一信号沿多条路径传输，同时或相隔极短的时间到达接收天线。&lt;br&gt;&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/06/3b0bac646faef2045c408753b7248cc6.png&#34; alt=&#34;&#34;&gt;&lt;br&gt;&#xA;由于反射信号路径更长，因此一般晚于主信号到达天线，多条路径之间的时间差称为时延扩展 delay spread。&lt;br&gt;&#xA;多径造成遗留的 802.11a/b/g 无线网络性能下降，因为多径会降低接收信号的强度和质量。&lt;br&gt;&#xA;但是，802.11n/ac 无线接口采用 MIMO 天线分集与 MRC 信号处理技术，使多径转变为提升网络性能的有利条件。&lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://wirelesspi.com/carrier-phase-based-ranging-in-indoor-multipath-channels/&#34;&gt;https://wirelesspi.com/carrier-phase-based-ranging-in-indoor-multipath-channels/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;增益&#34;&gt;增益&lt;/h3&gt;&#xA;&lt;p&gt;增益又称为放大，描述振幅或信号强度的增加。&lt;br&gt;&#xA;增益分为有源增益和无源增益，收发器 transceiver 产生有源增益，收发器和天线之间使用放大器也会产生有源增益；使用天线聚焦射频信号产生无缘增益，如下图。&lt;br&gt;&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/06/6a4be86a98cfbf4c24a96a3cedad5b2a.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>hugo slug 与 SEO</title>
      <link>https://blog.jaxwang.top/p/hugo-slug-seo/</link>
      <pubDate>Tue, 18 Jun 2024 21:47:30 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/hugo-slug-seo/</guid>
      <description>&lt;h1 id=&#34;what-is-seo&#34;&gt;What is SEO?&lt;/h1&gt;&#xA;&lt;p&gt;Search Engine Optimization，搜索引擎优化，是指通过一系列优化技术和策略，提高网站在搜索引擎结果页面（SERPs）中的排名。&lt;br&gt;&#xA;&lt;em&gt;当然这里的优化技术不是某度的竞价排名。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;what-is-slug&#34;&gt;What is slug?&lt;/h1&gt;&#xA;&lt;p&gt;&amp;ldquo;slug&amp;rdquo; 是一个术语，通常指的是一种友好的URL标识符。具体来说，slug 是用于标识一篇文章、页面或其他内容的一段文本字符串，通常是可读的，便于用户理解和搜索引擎优化（SEO）。&lt;br&gt;&#xA;slug 作为 url 的重要内容，我们还要对其进行优化：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;避免停用词，如 &amp;ldquo;and&amp;rdquo;, &amp;ldquo;or&amp;rdquo;, &amp;ldquo;but&amp;rdquo;, &amp;ldquo;the&amp;rdquo;, &amp;ldquo;a&amp;rdquo; 通常不影响内容的理解&lt;/li&gt;&#xA;&lt;li&gt;使用关键词&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;slug-in-hugo&#34;&gt;slug in Hugo&lt;/h1&gt;&#xA;&lt;p&gt;设置 &lt;code&gt;permalinks&lt;/code&gt; 启用 slug 作为 url。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;[permalinks]&#xA;note = &amp;quot;/note/:year/:month/:day/:slug/&amp;quot;&#xA;post = &amp;quot;/p/:slug/&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;在 Hugo 中，可以在每篇文章的 Front Matter 中设置 &lt;code&gt;slug&lt;/code&gt;。&lt;br&gt;&#xA;如果 &lt;code&gt;slug&lt;/code&gt; 没有设置，那么 hugo 会使用 &lt;code&gt;title&lt;/code&gt; 作为 &lt;code&gt;slut&lt;/code&gt; 的缺省值。&lt;br&gt;&#xA;通常我们设置一个 &lt;code&gt;slug&lt;/code&gt; 之后，hugo 还会进行优化：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;转化所有内容为小写&lt;/li&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;-&lt;/code&gt; 替代空格&lt;/li&gt;&#xA;&lt;li&gt;删除所有特殊字符&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Github Pages 自定义域名</title>
      <link>https://blog.jaxwang.top/p/githugpages-custom-domain/</link>
      <pubDate>Sun, 16 Jun 2024 10:02:46 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/githugpages-custom-domain/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site&#34;&gt;https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;要设置 &lt;code&gt;www&lt;/code&gt; 或自定义子域（例如 &lt;code&gt;www.example.com&lt;/code&gt; 或 &lt;code&gt;blog.example.com&lt;/code&gt;），必须在存储库设置中添加你的域。 然后，通过 DNS 提供商配置 CNAME 记录。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/06/1d87b2526b600efe583e6f5ad5b943d2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/06/db10a257fe7da679db3ec737c765df2a.png&#34; alt=&#34;&#34;&gt;&#xA;&lt;img src=&#34;https://img.jaxwang.top/2024/06/bc63044c346688d59471efa374a4ba22.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/06/2ecb7ed66a8bc0d395b9bc5d93ae4fd2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;关于域名解析记录的分类&lt;/em&gt;&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;类型&lt;/th&gt;&#xA;          &lt;th&gt;用途&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;A&lt;/td&gt;&#xA;          &lt;td&gt;用于将域名解析到 IPv4 address&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;AAAA&lt;/td&gt;&#xA;          &lt;td&gt;用于将域名解析到 IPv6 address&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CNAME&lt;/td&gt;&#xA;          &lt;td&gt;用于将域名解析到另一个域名 Canonical Name&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>Namesilo 域名解析到 CloudFlare</title>
      <link>https://blog.jaxwang.top/p/namesilo-transfer-cloudflare/</link>
      <pubDate>Sun, 16 Jun 2024 00:02:46 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/namesilo-transfer-cloudflare/</guid>
      <description>&lt;p&gt;购买流程就不详细描述了，从域名注册和使用 Cloudflare 解析开始写。&#xA;CloudFlare 提供域名解析服务，而且有免费 Plan 可以使用，因此下述流程的原理：&#xA;&lt;strong&gt;更换域名的默认解析服务器为 CloudFlare 域名解析服务器。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/06/3108c5f257ac30e75cc7c6b87cc30c39.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jacksonwang28.top/2024/06/e994285e96764300419592869b44e91e.png&#34; alt=&#34;&#34;&gt;&#xA;&lt;img src=&#34;https://img.jacksonwang28.top/2024/06/32cd4076260a592e355247922a4b1b1e.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jacksonwang28.top/2024/06/d9b9ca18695f36f3e5f6e108d73fec84.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用 CloudFlare R2 搭建图床</title>
      <link>https://blog.jaxwang.top/p/cloudflare-r2-image/</link>
      <pubDate>Sat, 15 Jun 2024 10:02:46 +0800</pubDate>
      <guid>https://blog.jaxwang.top/p/cloudflare-r2-image/</guid>
      <description>&lt;h1 id=&#34;为什么选择-cloudflare-r2&#34;&gt;为什么选择 Cloudflare R2&lt;/h1&gt;&#xA;&lt;p&gt;白嫖！白嫖！还是 TMD 白嫖！&lt;/p&gt;&#xA;&lt;p&gt;R2 计费基于存储的数据总量及对数据执行的两类操作。无需支付任何出口费用。免费额度对于我们个人用户完全够用。&lt;em&gt;(不被盗刷的情下)&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/06/336ed2df579dd1a99322b4d4b748978d.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;创建-bucket&#34;&gt;创建 Bucket&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/06/f0c424e0420f8dbe2b1ae5c73fab0c94.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/06/e277b0bd1504f73ac73a2697b078b0c8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;配置-bucket&#34;&gt;配置 Bucket&lt;/h1&gt;&#xA;&lt;p&gt;桶创建完毕之后，我们需要配置 Bucket，主要是添加自定义域名和创建令牌。前者用来公共访问我们 Bucket 中的文件，后者用来帮助我们上传到 Bucket。&lt;/p&gt;&#xA;&lt;p&gt;配置自定义域名：设置 -&amp;gt; 公开访问 -&amp;gt; 连接域&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/06/2e8d901c72db8e2c86924dfeea28bdcb.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/06/cf6abf7713d9dcb04535dfbdefdaf54e.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这里有 3 点要讲的：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;自定义是用来公开访问我们的桶的&lt;/li&gt;&#xA;&lt;li&gt;我们可以购买域名，然后在 Cloudflare 中注册管理&lt;/li&gt;&#xA;&lt;li&gt;注册管理域名之后，可以在域中添加已经注册的域或子域&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;em&gt;至于如何购买域名，在 CloudFlare 中注册可以 google it，或许我后面会出一期教程&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;创建令牌：管理令牌 -&amp;gt; 创建令牌&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/06/fc7545157f24d288c12ef5692699ebf4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/06/9ace4aab9389a9f72eae1bf0e29a68a2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/06/979c555739fffa1262bd09f0471ff1c4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;至此，令牌创建完毕，不要急着关闭此页面。&lt;/p&gt;&#xA;&lt;h1 id=&#34;配置-picgo&#34;&gt;配置 PicGo&lt;/h1&gt;&#xA;&lt;p&gt;PicGo 工具主要是用来帮助我们将图片上传到 R2 中。&lt;/p&gt;&#xA;&lt;p&gt;首先安装上插件 S3。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/06/902490696ab8dc359f92079522118f73.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img.jaxwang.top/2024/06/de2b251817590116a3d883a9d0876c6c.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
